# 1

现在有一个长度为n的排列1,2,3..n。现在小明希望将这个排列重新排列，要求每个位置和原来的数字不同，且相同位置的差的和最小。 

例如当n为3的原排列1,2,3，如果重排列后得到1,3,2，是不合法的，因为有相同位置数字相同。重排列为3,1,2是合法的。 

输入描述 一个整数n，3<=n<=10^12。 

输出描述 个整数，即题目中要求的最小的差值

```java
import java.util.*;

public class Main {
    static long minSum;
    static int n;
    static boolean[] used;
    static int[] perm;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();

        // 仅适合小 n，n>10 就不可行了！
        used = new boolean[n + 1];
        perm = new int[n];
        minSum = Long.MAX_VALUE;

        dfs(0);

        System.out.println(minSum);
    }

    static void dfs(int idx) {
        if (idx == n) {
            // 检查是否所有位置都不相同
            for (int i = 0; i < n; i++) {
                if (perm[i] == i + 1) return; // 不合法
            }
            // 计算差值和
            long sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.abs(perm[i] - (i + 1));
            }
            minSum = Math.min(minSum, sum);
            return;
        }
        for (int x = 1; x <= n; x++) {
            if (!used[x]) {
                used[x] = true;
                perm[idx] = x;
                dfs(idx + 1);
                used[x] = false;
            }
        }
    }
}

```

# 2

小A在餐馆打工，他的主要工作就是洗盘子。某一天餐厅有n个盘子需要清洗，从上到下编号1~n，小A只会每次拿最上面连续的若干个编号连续的盘子l~r，然后按照r~l的顺序来洗它们。现在，给出一个人洗这n个盘子的顺序，请你判断一下是否可能是小A洗盘子的顺序。
输入描述
第一行一个整数T表示数据组数。
对于每组数据:
第一行一个整数n.
第二行n个整数a1~an，数字间两两有空格隔开表示某个人洗盘子的顺序。
1<=n<=1000,1<=T≤50
输出描述
输出T行，每行一个单词，如果可能是小A洗的输出yes 否则输出 no

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();

            System.out.println(check(n, a) ? "yes" : "no");
        }
    }

    // 检查是否可能是小A的洗盘子顺序
    static boolean check(int n, int[] a) {
        int expected = 1; // 当前栈顶应该是 expected
        int i = 0;
        while (i < n) {
            // 当前段的起点
            int start = a[i];
            int j = i;
            // 找到连续递减的一段
            while (j + 1 < n && a[j + 1] == a[j] - 1) {
                j++;
            }
            int end = a[j];

            // 这一段必须是 expected ~ (expected + (start-end))
            if (end != expected) return false;

            // 更新 expected
            expected = start + 1;

            // 跳过这一段
            i = j + 1;
        }

        return expected == n + 1; // 所有盘子都被正确取走
    }
}
```

# 3

从子序列到子串(前端)
题目描述:
小钟有一个长度为n的字符串s。小钟可以对s执行如下操作:删除s的一个字符，并拼接剩下的字符串。例如字符串s=abcda，小钟可以删除第三个字符，从而得到新的字符串abda。
某一天，小钟得到了另一个长度为 m 的字符串 t。现在，小钟想知道最少删除s多少个字符，才能使得t作为s的某个连续子串出现。如果无论如何也不能使得t在s中出现，则输出-1.

输入描述
输入包括多组测试数据。
输入第一行包括一个正整数T(1≤T≤10)，表示测试数据的组数。
每组测试数据的第一行有两个整数 n(1≤n≤10%)，m(1≤m≤200)，分别表示 s 和t的长度;
第二行有一行字符串s;
第三行有一行字符串t。
保证每个测试点的所有测试数据的 nxm 的和均不超过`2x10^7`，保证所有字符均为小写字母。
输出描沭
对于每组测试数据，输出一个正整数表示使得t作为s的某个连续子串出现的最少删除字符个数。若不存在答案，则输出-1。