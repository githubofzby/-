# 算法题1

给定一个长度为n 的数组 a1,a2,···,an和一个整数 m，你需要回答q次询问，每一次询问给定一个x。随后，按照下方步骤进行一元二次函数的构造: 

1. 初始化 a=0、b=0、c=0。 
2. 遍历序列 a1,a2,...,an，每次遍历将 ai 累加到 a、b、c 三个值中的其中任意一个值上。
3. 保证 a、b、c都要被至少累加 1次。

于是你构造出了一个二次函数f(x)=a·x^2+bx+c。对于每一个询问，请你计算出最大的 f(x)mod m(注意是取模后的最大值) 

注意，每一次询问构造独立，互不干扰。

> 输入描述

第一行输入三个整数n,m,q(n=3; 2≤m≤648; 1≤q≤100) 

第二行输入 n 个整数a1,a2,...,an(1≦ai≤10^6)

第三行输入q个整数x1,x2,...,xq(0≤xi<10^6) 

> 输出

对于每一个询问，输出一个整数，表示 f(x) mod m 的最大值。

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        FastScanner fs = new FastScanner(System.in);

        int n = fs.nextInt(); // 题目保证 n==3
        int m = fs.nextInt();
        int q = fs.nextInt();

        long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = fs.nextLong();

        long[] xs = new long[q];
        for (int i = 0; i < q; i++) xs[i] = fs.nextLong();

        // 生成 3! = 6 种排列
        int[][] perms = {
            {0,1,2},
            {0,2,1},
            {1,0,2},
            {1,2,0},
            {2,0,1},
            {2,1,0}
        };

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < q; i++) {
            long x = xs[i];
            long best = 0;
            for (int[] p : perms) {
                long aa = a[p[0]];
                long bb = a[p[1]];
                long cc = a[p[2]];
                // 计算 f(x) = aa*x^2 + bb*x + cc，注意可能较大，用 long
                long fx = aa * x * x + bb * x + cc;
                long mod = fx % m;
                if (mod < 0) mod += m;
                if (mod > best) best = mod;
                // 若达到 m-1 可提前剪枝（可选）
                if (best == m - 1) break;
            }
            sb.append(best);
            if (i + 1 < q) sb.append('\n');
        }

        System.out.print(sb.toString());
    }

    // 简单高效输入
    static class FastScanner {
        private final InputStream in;
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;

        FastScanner(InputStream is) { this.in = is; }

        private int read() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0) return -1;
            }
            return buffer[ptr++];
        }

        long nextLong() throws IOException {
            int c;
            while ((c = read()) <= ' ') {
                if (c == -1) return Long.MIN_VALUE;
            }
            int sign = 1;
            if (c == '-') { sign = -1; c = read(); }
            long val = 0;
            while (c > ' ') {
                val = val * 10 + (c - '0');
                c = read();
            }
            return val * sign;
        }

        int nextInt() throws IOException { return (int) nextLong(); }
    }
}
```

# 算法题2

给定两个整数x与y。你可以进行若干次操作(可以为零次)，目标是同时把两者都变为 0。每一轮从下列三种操作中任选其一执行: 

+ 单点步:支付a元，将x或y中的一个数增加 1或减少 1(过程中数值可以为负);
+ 联动步:支付b元，同时将x与y名增加 1或各减少 1(两者同向变化，过程中数值可以为负);
+ 平衡券:支付c元，将(x,y)变为(x+1,y-1)或(x-1,y+1)(两者反向变化，过程中数值可以为负)。

请计算使(x,y)变为(0,0)的最小总花费。操作次数不限。

输入描述： 每个测试文件均包含多组测试数据。第一行输入一个整数 t (1 ≤t≤ 10^4)代表数据组数，每组测试数据描述如下:在一行上输入五个整数 x,y,a, b,c (-10^9≤x,y≤ 10^9 ; 1 ≤a,b,c≦ 10^9 ). 

 输出描述： 对于每一组测试数据，新起一行输出一个整数，表示将(x,y)变为(0,0)的最小总花费。
示例：

```
2
3 3 5 3 100
4 -1 2 7 3
```

输出

```
9
9
```

```java
// 暴力
import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        
        while (t-- > 0) {
            long x = sc.nextLong();
            long y = sc.nextLong();
            long a = sc.nextLong();
            long b = sc.nextLong();
            long c = sc.nextLong();
            
            System.out.println(solve(x, y, a, b, c));
        }
        
        sc.close();
    }
    
    public static long solve(long x, long y, long a, long b, long c) {
        // 我们需要考虑不同的策略组合
        long minCost = Long.MAX_VALUE;
        
        // 策略1: 只使用单点步
        long cost1 = (Math.abs(x) + Math.abs(y)) * a;
        minCost = Math.min(minCost, cost1);
        
        // 策略2: 尽可能使用联动步，剩余用单点步
        long common = Math.min(Math.abs(x), Math.abs(y));
        long remaining = Math.abs(x) + Math.abs(y) - 2 * common;
        long cost2 = common * b + remaining * a;
        minCost = Math.min(minCost, cost2);
        
        // 策略3: 考虑使用平衡券
        // 我们可以枚举使用多少次平衡券
        // 平衡券可以调整 x 和 y 的相对差值
        
        // 如果 x 和 y 同号，我们可以用平衡券让其中一个变为0
        if (x * y >= 0) {
            // 使用平衡券将较小绝对值的那个变为0
            long minAbs = Math.min(Math.abs(x), Math.abs(y));
            long maxAbs = Math.max(Math.abs(x), Math.abs(y));
            
            // 用平衡券消除较小的那个，然后用单点步处理剩余
            long cost3 = minAbs * c + maxAbs * a;
            minCost = Math.min(minCost, cost3);
            
            // 用平衡券消除较小的那个，然后用联动步处理剩余
            long cost4 = minAbs * c + maxAbs * b;
            minCost = Math.min(minCost, cost4);
        }
        
        // 策略4: 如果 x 和 y 异号，考虑用平衡券调整后再用联动步
        if (x * y < 0) {
            long sum = Math.abs(x) + Math.abs(y);
            long diff = Math.abs(Math.abs(x) - Math.abs(y));
            
            // 用平衡券调整到同号，然后用联动步
            if (sum % 2 == 0) {
                long cost5 = (sum / 2) * c + 0 * a; // 完全用平衡券
                minCost = Math.min(minCost, cost5);
            } else {
                long cost6 = (sum / 2) * c + a; // 平衡券 + 一步单点步
                minCost = Math.min(minCost, cost6);
            }
        }
        
        // 更精确的枚举策略
        // 枚举平衡券的使用次数
        for (int delta = -Math.abs((int)(x + y)); delta <= Math.abs((int)(x + y)); delta++) {
            // 使用 |delta| 次平衡券后
            long newX, newY;
            if (delta >= 0) {
                newX = x + delta;
                newY = y - delta;
            } else {
                newX = x + delta;
                newY = y - delta;
            }
            
            // 现在用联动步和单点步的组合
            long commonSteps = Math.min(Math.abs(newX), Math.abs(newY));
            long remainingSteps = Math.abs(newX) + Math.abs(newY) - 2 * commonSteps;
            
            long totalCost = Math.abs(delta) * c + commonSteps * b + remainingSteps * a;
            minCost = Math.min(minCost, totalCost);
        }
        
        return minCost;
    }
}
```

# 算法3

小美有一个正整数 n，小美想要构造一个长度为 n 的正整数数组 a，满足 `1≤i<n,lcm(ai,ai+1)= n`，也就是说对于数组任意相邻两项的最小公倍数都等于 n。

但是小美觉得这个问题太简单了，所以希望你帮他求出一共有多少个数组 a 满足这个条件。 

由于答案可能很大，请将答案对 10^9 + 7 取模后输出。

输入一个正整数n. `2 <= n <= 10^18`

输出一个整数，是对`10^9 + 7`取模后的结果

> 示例

输入 `114514`

输出`159196343`

```java
import java.io.*;
import java.util.*;

public class Main {
    static final long MOD = 1_000_000_007L;

    public static void main(String[] args) throws Exception {
        FastScanner fs = new FastScanner(System.in);
        long n = fs.nextLong();
        // 如果题目保证 n>=2 可以去掉此判断
        if (n == 1) {
            System.out.println(1);
            return;
        }

        // 因式分解 n -> 列出 (prime, exponent)
        long tmp = n;
        List<long[]> factors = new ArrayList<>(); // each item: [prime, exp]
        for (long p = 2; p * p <= tmp; p += (p==2?1:2)) {
            if (tmp % p == 0) {
                long e = 0;
                while (tmp % p == 0) {
                    tmp /= p;
                    e++;
                }
                factors.add(new long[]{p, e});
            }
        }
        if (tmp > 1) factors.add(new long[]{tmp, 1});

        long ans = 1L;
        for (long[] pe : factors) {
            long exp = pe[1]; // alpha
            long k = exp;     // 非E 的取值数 = alpha (指数 0..alpha-1)

            // For this prime, compute count for length = n using matrix pow.
            // v1 = [1, k]^T, M = [[1,1],[k,0]], v_n = M^(n-1) * v1
            long[][] M = new long[][]{{1, 1}, {k % MOD, 0}};
            long[][] P = matPow(M, n - 1);
            // v_n = P * v1
            long dp1 = ( (P[0][0] * 1L + P[0][1] * (k % MOD)) % MOD );
            long dp2 = ( (P[1][0] * 1L + P[1][1] * (k % MOD)) % MOD );
            long total = (dp1 + dp2) % MOD;
            ans = (ans * total) % MOD;
        }

        System.out.println(ans % MOD);
    }

    // 2x2 matrix multiplication mod
    static long[][] mul(long[][] A, long[][] B) {
        long[][] C = new long[2][2];
        C[0][0] = ( (A[0][0]*B[0][0] % MOD) + (A[0][1]*B[1][0] % MOD) ) % MOD;
        C[0][1] = ( (A[0][0]*B[0][1] % MOD) + (A[0][1]*B[1][1] % MOD) ) % MOD;
        C[1][0] = ( (A[1][0]*B[0][0] % MOD) + (A[1][1]*B[1][0] % MOD) ) % MOD;
        C[1][1] = ( (A[1][0]*B[0][1] % MOD) + (A[1][1]*B[1][1] % MOD) ) % MOD;
        return C;
    }

    static long[][] matPow(long[][] M, long exp) {
        long[][] res = new long[][]{{1,0},{0,1}}; // identity
        long[][] base = new long[][]{{M[0][0]%MOD, M[0][1]%MOD}, {M[1][0]%MOD, M[1][1]%MOD}};
        while (exp > 0) {
            if ((exp & 1L) == 1L) res = mul(res, base);
            base = mul(base, base);
            exp >>= 1;
        }
        return res;
    }

    // 快速输入类
    static class FastScanner {
        private final InputStream in;
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;

        FastScanner(InputStream is) { this.in = is; }

        private int read() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0) return -1;
            }
            return buffer[ptr++];
        }

        long nextLong() throws IOException {
            int c;
            while ((c = read()) <= ' ') if (c == -1) return Long.MIN_VALUE;
            int sign = 1;
            if (c == '-') { sign = -1; c = read(); }
            long val = 0;
            while (c > ' ') {
                val = val * 10 + (c - '0');
                c = read();
            }
            return val * sign;
        }
    }
}

```

