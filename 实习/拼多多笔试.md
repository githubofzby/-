# 拼多多笔试

## 第一题

多多君正在研究字符串数组的单调性。他定义一个字符串数组为单调不降当且仅当对于所有相邻元素 s[i] 和 s[i+1]，都有 s[i] ≤ s[i+1]，其中≤表示:
1.首先按照字符串的长度比较，长度更长的字符串更大，如 banana >apple
2.在长度相等的情况下，按字符串的字典序比较，字典序较大的字符串更大，如cherry > banana
给定若干组测试数据，每组数据包含一个字符串数组。你需要计算该数组中最长的单调不降连续子数组的长度。
输入描述
第一行为一个整数T(1≤T≤1000),表示测试用例的数量。
接下来的 2T 行，每两行表示一组测试用例:
第一行为当前测试用例输入的字符串数组的长度n(1≤ n≤1000)
第二行为n个由空格分隔的字符串，对应字符串数组中的每个元素;其中每个字符串仅包含小写字母，长度不超过20
输出描述
输出包含T行	
每一行为对应测试用例中，最长的单调不降连续子数组的长度
补充说明
20%数据满足n≤100，50%数据满足n≤500100%数据满足n≤1000
长度为1的字符串数组也可以视为单调不降

```java
import java.util.Scanner;

public class MonotonicStringArray {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt(); // 测试用例数量
        
        for (int t = 0; t < T; t++) {
            int n = scanner.nextInt(); // 字符串数组长度
            scanner.nextLine(); // 消耗换行符
            
            String[] arr = scanner.nextLine().split(" ");
            System.out.println(findLongestMonotonicSubarray(arr, n));
        }
        
        scanner.close();
    }
    
    // 判断字符串s1是否小于等于s2（根据题目规则）
    private static boolean isLessOrEqual(String s1, String s2) {
        // 首先按照长度比较
        if (s1.length() != s2.length()) {
            return s1.length() < s2.length();
        }
        // 长度相等时按字典序比较
        return s1.compareTo(s2) <= 0;
    }
    
    // 找到最长单调不降连续子数组的长度   
    private static int findLongestMonotonicSubarray(String[] arr, int n) {
        if (n == 0) return 0;
        
        int maxLength = 1; // 至少有一个元素
        int currentLength = 1;
        
        for (int i = 1; i < n; i++) {
            if (isLessOrEqual(arr[i-1], arr[i])) {
                // 当前元素大于等于前一个元素，子数组长度增加
                currentLength++;
                maxLength = Math.max(maxLength, currentLength);
            } else {
                // 不满足条件，重新开始计数
                currentLength = 1;
            }
        }
        
        return maxLength;
    }
}
```

## 第二题

多多君在处理一个由左括号(和右括号)组成的字符串，多多君每次处理时可以顺序读取一个字符或者一个有效括号子串，求问多多君的最小处理次数

输入描述	
第一行输入为一个整数N,表示字符串的总长度(1<=N<=10,000)
第二行输入为一个长度为N字符串，字符串由 '(' 和 )' 组成
输出描述	
输出为一个整数，表示字符串的最小处理次数
补充说明
有效括号子串需要满足:
1.括号成对闭合:每个'('都有一个对应的')'
2.正确嵌套顺序:右括号不能出现在对应的左括号之前
例如:“()”、“()()”、“(()())”均为有效括号子串，“)("、"(()"、"()())"不是有效括号子串

**第二题先改一下**

```java
import java.util.Scanner;

public class BracketProcessing {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        scanner.nextLine(); // 消耗换行符
        String s = scanner.nextLine();
        
        System.out.println(minProcessingTimes(s));
        scanner.close();
    }
    
    public static int minProcessingTimes(String s) {
        int n = s.length();
        // dp[i]表示处理前i个字符的最小次数
        int[] dp = new int[n + 1];
        
        // 初始化
        dp[0] = 0;
        
        for (int i = 1; i <= n; i++) {
            // 默认情况：单独处理当前字符
            dp[i] = dp[i - 1] + 1;
            
            // 如果当前字符是右括号，检查是否可以形成有效括号子串
            if (s.charAt(i - 1) == ')') {
                // 从i-1向前检查
                int leftCount = 0;
                
                for (int j = i - 1; j >= 0; j--) {
                    if (s.charAt(j) == ')') {
                        leftCount--;
                    } else {
                        leftCount++;
                    }
                    
                    // 如果左括号数量等于右括号数量，说明从j到i-1是平衡的
                    if (leftCount == 0) {
                        // j从0开始计数，所以对应s的索引是j
                        dp[i] = Math.min(dp[i], dp[j] + 1);
                    }
                }
            }
        }
        
        return dp[n];
    }
}
```

## 第三题

计算机进程运行时必须使用某些不能共享的资源，在获取到所有必须资源之前，都不会释放已持有的资源，然而资源的总数是有限的，多个进程容易出现先持有部分资源、循环等待其他进程释放资源、进而导致所有进程都处于阻塞状态的情况，称之为
列死锁。	

我们将资源种类从1到m编号，每种资源的未被持有数量为ai。
将进程从1到n编号，第i个进程已持有资源hi种，持有第 hrij种资源 hcij个，等待资源 wi种，等待第 wrij 种资源 wcij个。
当未被持有的资源数满足某个进程的等待资源数时，进程得以执行，执行完成后可释放所有已持有资源，被释放的资源变为未被持有状态。
当所有可释放资源都变为未持有状态，仍有进程处于等待状态时，这些进程被认为处于死锁状态，我们零要找出资源按最优分配情况下仍处于死锁状态的进程编号。

输入描述
第一行为两个整数n,m(1≤n,m≤10^5),第二行为m个整数ai(0≤ai≤10^9),表示每种资源的数量，接下去2n行:

-第2i+1行表示第i个进程已持有资源情况:第一个整数hi(0≤hi≤m),接下去2hi个整数，第 2j个整数为hrij(1≤hrij≤m),第 2j+1个整数为hcij(1≤hcij≤10^9); 

-第 2i+2行表示第i个进程等待资源情况:第一个整数wi(0≤wi≤m),接下去 2wi个整数,第 2j个整数为wrij(1≤wrij≤m),第2j+1个整数为wcij(1 ≤wcj≤10^9)。
数据保证 i=1 hi∈[1,105], i=1 wi∈[1,105]，对于任意j1≠j2，都有 hrij_1 ≠ hrij_2, wrij_1≠wrij_2
**做做第三题，过点案例就算了**

```java
import java.util.*;

public class DeadlockDetection {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 读取进程数和资源种类数
        int n = scanner.nextInt(); // 进程数
        int m = scanner.nextInt(); // 资源种类数
        
        // 读取每种资源的可用数量
        long[] available = new long[m + 1]; // 下标从1开始，与题目对应
        for (int i = 1; i <= m; i++) {
            available[i] = scanner.nextLong();
        }
        
        // 存储每个进程持有和等待的资源
        List<Map<Integer, Long>> hold = new ArrayList<>();
        List<Map<Integer, Long>> wait = new ArrayList<>();
        // 初始化，添加一个空元素使下标从1开始
        hold.add(new HashMap<>());
        wait.add(new HashMap<>());
        
        // 读取每个进程的资源持有和等待情况
        for (int i = 1; i <= n; i++) {
            // 处理已持有资源
            Map<Integer, Long> holdMap = new HashMap<>();
            int hi = scanner.nextInt(); // 持有资源种类数
            for (int j = 0; j < hi; j++) {
                int resourceType = scanner.nextInt(); // 资源类型
                long count = scanner.nextLong(); // 资源数量
                holdMap.put(resourceType, count);
            }
            hold.add(holdMap);
            
            // 处理等待资源
            Map<Integer, Long> waitMap = new HashMap<>();
            int wi = scanner.nextInt(); // 等待资源种类数
            for (int j = 0; j < wi; j++) {
                int resourceType = scanner.nextInt(); // 资源类型
                long count = scanner.nextLong(); // 资源数量  
                waitMap.put(resourceType, count);
            }
            wait.add(waitMap);
        }
        
        // 死锁检测
        boolean[] finished = new boolean[n + 1]; // 标记进程是否完成
        boolean changed = true; // 标记是否有进程完成
        
        while (changed) {
            changed = false;
            for (int i = 1; i <= n; i++) {
                if (finished[i]) continue; // 已完成的进程跳过
                
                boolean canProceed = true;
                // 检查是否所有等待的资源都可满足
                for (Map.Entry<Integer, Long> entry : wait.get(i).entrySet()) {
                    int resourceType = entry.getKey();
                    long needed = entry.getValue();
                    if (available[resourceType] < needed) { 
                        canProceed = false;
                        break;
                    }
                }
                
                if (canProceed) {
                    // 进程可以执行，释放所有持有资源
                    for (Map.Entry<Integer, Long> entry : hold.get(i).entrySet()) {
                        int resourceType = entry.getKey();
                        long count = entry.getValue();
                        available[resourceType] += count;
                    }
                    finished[i] = true;
                    changed = true;
                }
            }
        }  
        
        // 输出死锁进程
        List<Integer> deadlocked = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            if (!finished[i]) {
                deadlocked.add(i);
            }
        }
        
        // 按照编号排序并输出
        Collections.sort(deadlocked);
        if (deadlocked.isEmpty()) {
            System.out.println("0");
        } else {
            System.out.print(deadlocked.size());
            for (int pid : deadlocked) {
                System.out.print(" " + pid);
            }
            System.out.println();
        }
    }
}
```

// 第四题不敢答了

## 第四题

在一个简单的哈希表实现中，对于给定哈希函数 f(x)=x%n,有一长度为n的数组用于存储 x(x≥0)值。
当需要向哈希表插入一个值x时，从数组的下标 f(x)开始，向右循环移动，找到第一个未存储过数字的位置，写入x，若哈希表已满或x已存在于表中，则不再插入x。
给定n个整数ai(ai≥-1)表示哈希表数组中存储的元素，-1表示当前位置未写入数据。
请计算有多少种合法的插入序列(假设插入过程中不存在相同的数字)，使得哈希表中存储的状态与输入完全一致。
输入描述
第一行为一个正整数n，第二行为n个整数a1,a2,..,an，含义如题。输入保证序列为通过线性探测插入的合法的哈希表结果。(除ai=-1外，其它数字两两互不相等。)
输出描述
输出答案对 998244353取余的结果。
补充说明
对于50%的数据,1≤n≤1000;
对于100%的数据，
1≤n≤10^5,-1≤ai≤10^9.







