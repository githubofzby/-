给定一个未排序的整数数组 nums ，找出数字连续的最长序列(不要求序列元素在原数组中连续)的长度。请你设计并实现时间复杂度为 o(n)的算法解决此问题。
补充说明：
0 <= nums.length <= 10^5
-10^9 <= nums[] <= 10^9
示例1:
```
[100,4,200,1,3,2]
```
输出：4
最长数字连续序列是[1,2,3,4]，长度为4
- 暴力解法：对于每个数字，尝试找它的连续序列。但这样时间复杂度会是O(n²)或更高。
- 排序解法：先排序，然后遍历找连续序列。但排序的时间复杂度是O(nlogn)，不满足O(n)的要求。
- 哈希集合解法：这是满足O(n)时间复杂度的最优解法。
    - 首先将所有数字放入HashSet中，这样查找的时间复杂度是O(1)
    - 对于每个数字，我们只在它是某个连续序列的起点时才开始计数
    - 如何判断是起点？检查num-1是否存在于集合中，如果不存在，说明num是一个序列的起点
    - 然后从这个起点开始，不断检查num+1, num+2, ...是否存在，计算连续序列的长度

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        // 处理空数组的情况
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        // 将所有数字放入HashSet，方便O(1)时间查找
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }
        
        int maxLength = 0;
        
        // 遍历集合中的每个数字
        for (int num : numSet) {
            // 关键优化：只在num是序列起点时才开始计数
            // 如果num-1存在，说明num不是起点，跳过
            if (!numSet.contains(num - 1)) {
                int currentNum = num;
                int currentLength = 1;
                
                // 从起点开始向后扩展，查找连续的数字
                while (numSet.contains(currentNum + 1)) {
                    currentNum++;
                    currentLength++;
                }
                
                // 更新最大长度
                maxLength = Math.max(maxLength, currentLength);
            }
        }
        
        return maxLength;
    }
}
```