# 算法题1

小红正在数偶数0，2，4，6，8，10并将这些数依次拼接成一个无穷长字符串"0246810121416..." 现给定一个正整数 n，请你确定该字符串的第n 个字符是什么(下标从1开始)。

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long n = sc.nextLong(); // 输入 n
        System.out.println(findNthChar(n));
    }

    public static char findNthChar(long n) {
        long count = 0;   // 已经生成的字符数
        long even = 0;    // 当前偶数

        while (true) {
            String s = String.valueOf(even);
            if (count + s.length() >= n) {
                // 第 n 个字符在这个偶数中
                return s.charAt((int) (n - count - 1));
            }
            count += s.length();
            even += 2;
        }
    }
}
```

# 算法题2

由N个1 x 1单元格组成的1 x N的条形格请你找到最大的K，使他满足将条形格分为一个1 x K的区域，两个1 x K-1的区域，三个1 x K- 2的区域.…K个1 x 1的区域。需要注意的是，这些区域不可接触。
## 问题分析

可以将格子分为一下区域

```
1 个 1×K 的区域
2 个 1×(K-1) 的区域
3 个 1×(K-2) 的区域
...
K 个 1×1 的区域
```

总单元格数的最小值为： 
$$
N_{\min}=1\cdot K+2\cdot(K-1)+3\cdot(K-2)+\cdots+K\cdot 1
$$
等价地写成求和形式： 
$$
N_{\min}=\sum_{i=1}^{K} i\cdot (K-i+1)
$$
**公式化求和**

展开并整理： 
$$
\sum_{i=1}^{K} i\cdot(K-i+1) =\sum_{i=1}^{K} \bigl(i(K+1)-i^2\bigr) =(K+1)\sum_{i=1}^{K} i-\sum_{i=1}^{K} i^2
$$


利用等差与平方和公式： 
$$
 \sum_{i=1}^{K} i=\frac{K(K+1)}{2},\qquad \sum_{i=1}^{K} i^2=\frac{K(K+1)(2K+1)}{6}
$$


代入得： 
$$
\begin{aligned} N_{\min} &=(K+1)\cdot \frac{K(K+1)}{2}-\frac{K(K+1)(2K+1)}{6} =K(K+1)\left(\frac{K+1}{2}-\frac{2K+1}{6}\right) =K(K+1)\cdot \frac{3(K+1)-(2K+1)}{6}=K(K+1)\cdot \frac{K+2}{6}. \end{aligned}
$$


------

结论（关键公式）： 
$$
\boxed{N_{\min}=\frac{K(K+1)(K+2)}{6}}
$$

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long N = sc.nextLong();
        System.out.println(findMaxK(N));
    }

    public static long findMaxK(long N) {
        long left = 1, right = N, ans = 0;
        while (left <= right) {
            long mid = left + (right - left) / 2;
            // 使用公式计算需要的单元格数，注意防止溢出
            long need = mid * (mid + 1) * (mid + 2) / 6;
            if (need <= N) {
                ans = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return ans;
    }
}

```

# 算法题3

牛牛是一个快递员，负责几个乡村的配送，乡村编号从1到n。快递站设在第8号乡村，牛牛将依次配送q件快递到目的乡村。
乡村之间有 m 条单向道路和 k条双向道路连接，走完第i条道路耗时为$w_i$。已知任意两个乡村均可以相互到达，牛牛每次都选择耗时最短的路径。
第i件快递配送到乡村$d_i$后，若此时牛牛配送全部快递的总耗时t(即前之-1件快递的配送用时、投递用时之和加上第之件快递的配送用时)为奇数，牛牛就会通知收货人当面取快递(该操作耗时a个单位时间);否则牛牛就会将快递放入快递柜中(该操作耗时b个单位时间)。不需要考虑其它任何额外因素对耗时的影响。
配送完所有快递后，牛牛从最后一个目的乡村返回快递站休息。问牛牛配送完所有q件快递并返回快递站的总耗时是多少?

输入描述：

- 第一行四个整数：`n m k s`
  - n：乡村数量
  - m：单向道路数量
  - k：双向道路数量
  - s：快递站编号（起点）
- 接下来m 行：单向道路 `(ui, vi, wi)`
- 接下来 k 行：双向道路 `(uj, vj, wj)`
- 接下来一行：三个整数 `a b q`
  - a：当面取件耗时
  - b：投递快递柜耗时
  - q：快递数量
- 接下来一行：q 个整数 `d1 d2 ... dq`，配送顺序、

 输出总耗时

```java
import java.util.*;

class Edge {
    int to;
    long weight;
    Edge(int to, long weight) {
        this.to = to;
        this.weight = weight;
    }
}

public class DeliveryGraph {
    static int n;
    static List<Edge>[] graph;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 第一行输入
        n = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();
        int s = sc.nextInt(); // 快递站起点

        // 初始化图
        graph = new List[n+1];
        for (int i = 1; i <= n; i++) graph[i] = new ArrayList<>();

        // 单向道路
        for (int i = 0; i < m; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            int w = sc.nextInt();
            graph[u].add(new Edge(v, w));
        }

        // 双向道路
        for (int i = 0; i < k; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            int w = sc.nextInt();
            graph[u].add(new Edge(v, w));
            graph[v].add(new Edge(u, w));
        }

        // a, b, q
        long a = sc.nextLong();
        long b = sc.nextLong();
        int q = sc.nextInt();

        // 配送顺序
        int[] dest = new int[q];
        for (int i = 0; i < q; i++) dest[i] = sc.nextInt();

        long totalTime = 0;
        int current = s;

        for (int i = 0; i < q; i++) {
            long[] dist = dijkstra(current);
            long travelTime = dist[dest[i]];
            long t = totalTime + travelTime;
            totalTime += travelTime;
            if (t % 2 == 1) totalTime += a;
            else totalTime += b;
            current = dest[i];
        }

        // 回到快递站
        long[] distBack = dijkstra(current);
        totalTime += distBack[s];

        System.out.println(totalTime);
    }

    static long[] dijkstra(int start) {
        long[] dist = new long[n+1];
        Arrays.fill(dist, Long.MAX_VALUE);
        dist[start] = 0;
        PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(o -> o[1]));
        pq.offer(new long[]{start, 0});

        while (!pq.isEmpty()) {
            long[] cur = pq.poll();
            int u = (int) cur[0];
            long d = cur[1];
            if (d > dist[u]) continue;
            for (Edge e : graph[u]) {
                int v = e.to;
                long w = e.weight;
                if (dist[v] > dist[u] + w) {
                    dist[v] = dist[u] + w;
                    pq.offer(new long[]{v, dist[v]});
                }
            }
        }
        return dist;
    }
}

```

