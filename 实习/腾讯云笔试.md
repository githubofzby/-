# 5月28日上午

## 第一题

编写一个程序，给定一个由大写字母组成的字符串S，求S中没有出现的大写字母的ASCII码值之和。

当字符串S为“ABCDEFGHIJKLMNOPQRSTUVW“时，未出现在S中的大写字母为 X、Y 和Z。X的ASCII码值为88，y为89，Z为90，所以这些ASCII码值之和为267。

输入描述：

一行中中给定字符串S。

S仅由字母表中的大写字母组成，最多1000个字母.

输出描述：

输入给定字符串S中没有出现的大写字母ASCII码值之和

```java
import java.util.Scanner;

public class MissingLettersASCIISum {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String S = scanner.nextLine();
        scanner.close();
        
        // 创建一个布尔数组来标记哪些大写字母出现在字符串S中
        boolean[] present = new boolean[26];
        
        // 遍历字符串S，标记出现的字母
        for (int i = 0; i < S.length(); i++) {
            char c = S.charAt(i);
            if (c >= 'A' && c <= 'Z') {
                present[c - 'A'] = true;
            }
        }
        
        // 计算未出现字母的ASCII码值之和
        int sum = 0;
        for (int i = 0; i < 26; i++) {
            if (!present[i]) {
                // 大写字母A的ASCII码是65，所以第i个大写字母的ASCII码是65+i
                sum += (65 + i);
            }
        }
        
        System.out.println(sum);
    }
}
```

## 第二题

密文是仅由一行小写字母构成;牛牛想要破解该密文;
己知密码破解规则如下:

+ 如果字符str[i]为元音字母;则该处的字符的明文是它本身;
+ 若字符str[j]为辅音字母:则该处的字符的明文将破解为三个字符:
  1. 辅音字母本身;
  2. 在字母表中最接近该辅音字母的元音字母，若该辅音字母正好落于两个元音字母之间，那么将选择更接近字母表开头的元音字母;若辅音字母为'c'，则选择元音字母‘a’，而不是‘e’；
  3. 字母表中原始辅音字母之后的下一个辅音字母;若该字母为d,则将选择下一个辅音字母'f';注意:‘z’的下一个辅音字母是他本身。

例如:密文nowcoder的明文是nopowuxcadodeferos;
由于破解后的明文太过冗长，牛牛想知道明文的长度比密文长多少?现在给你一行字符串，请你输出明文比密文长多少

## 第三题

给定一个仅由数字1到9组成的字符串s，你可以在字符串s中任意两个相邻的数字字符之间插入加号运算符'+’。每对相邻数字可选择插入一个加号或不插入加号。

通过不同的插入方式，可以构成多种不同的数学表达式。例如，对于字符串"1234"以下是全部的合法表达式:

+ "1234"(没有插入加号);
+ "1+234"
+ "12+34"
+ "123+4"
+ "1+2+34"
+ "12+3+4"
+ "1+2+3+4"

然而，像"1+2++3+4"这样的插入方式是不合法的，因为在'2’和'3’之间插入了多个加号。

对于给定的字符串s，请计算所有通过合法插入'+‘，构成的数学表达式中，有多少个表达式的计算结果是一个质数。

输入描述：

在一行上输入一个长度为1 <= len(s)<= 15，仅由数字字符'1’到'9’组成的字符串 s。

输出描述：

输出一个整数，代表计算结果为质数的合法表达式的数量。
**正确代码：**

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        scanner.close();
        
        int count = 0;
        int n = s.length();
        // 使用位运算遍历所有可能的加号插入位置
        // 对于长度为n的字符串，有n-1个可能的插入位置，因此总共有2^(n-1)种可能性
        for (int mask = 0; mask < (1 << (n - 1)); mask++) {
            // 构造表达式
            StringBuilder expr = new StringBuilder();
            expr.append(s.charAt(0));
            for (int i = 0; i < n - 1; i++) {
                if ((mask & (1 << i)) != 0) expr.append('+');
                expr.append(s.charAt(i + 1));
            }
            // 计算表达式的值
            long result = evaluateExpression(expr.toString());
            // 检查结果是否为质数
            if (isPrime(result)) count++;
        }
        System.out.println(count);
    }
    
    // 计算表达式的值
    private static long evaluateExpression(String expr) {
        String[] parts = expr.split("\\+");
        long sum = 0;
        for (String part : parts) {
            sum += Long.parseLong(part);
        }
        return sum;
    }
    
    // 判断一个数是否为质数
    private static boolean isPrime(long n) {
        if (n <= 1) {
            return false;
        }
        if (n <= 3) {
            return true;
        }
        if (n % 2 == 0 || n % 3 == 0) {
            return false;
        }
        
        long i = 5;
        while (i * i <= n) {
            if (n % i == 0 || n % (i + 2) == 0) {
                return false;
            }
            i += 6;
        }
        
        return true;
    }
}
```

错误：

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class PrimeExpressions {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        scanner.close();
        
        List<String> expressions = generateExpressions(s);
        int count = 0;
        
        for (String expr : expressions) {
            long result = evaluateExpression(expr);
            if (isPrime(result)) {
                count++;
            }
        }
        
        System.out.println(count);
    }
    
    // 生成所有可能的表达式
    private static List<String> generateExpressions(String s) {
        List<String> result = new ArrayList<>();
        generateExpressionsHelper(s, 0, "", result);
        return result;
    }
    
    private static void generateExpressionsHelper(String s, int index, String current, List<String> result) {
        if (index == s.length()) {
            result.add(current);
            return;
        }
        // 当前数字
        char digit = s.charAt(index);
        // 如果当前表达式为空，直接添加数字
        if (current.isEmpty()) {
            generateExpressionsHelper(s, index + 1, current + digit, result);
        } else {
            // 不插入加号
            generateExpressionsHelper(s, index + 1, current + digit, result);
            // 插入加号
            generateExpressionsHelper(s, index + 1, current + "+" + digit, result);
        }
    }
    
    // 计算表达式的值
    private static long evaluateExpression(String expr) {
        String[] parts = expr.split("\\+");
        long sum = 0;
        
        for (String part : parts) {
            // 处理前导零的情况
            long num = Long.parseLong(part);
            sum += num;
        }
        
        return sum;
    }
    
    // 判断一个数是否为质数
    private static boolean isPrime(long n) {
        if (n <= 1) {
            return false;
        }
        if (n <= 3) {
            return true;
        }
        if (n % 2 == 0 || n % 3 == 0) {
            return false;
        }
        
        long i = 5;
        while (i * i <= n) {
            if (n % i == 0 || n % (i + 2) == 0) {
                return false;
            }
            i += 6;
        }
        
        return true;
    }
}
```





