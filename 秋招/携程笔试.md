给定一个三位整数 n，判断n 是否为一个(十进制下的)三位水仙花数。若是，输出YES，否则输出 NO。
三位水仙花数:设n 的十进制表示为 abc(a,b,c为各位数字，且a≠ 0)，当且仅当n=a的3次+b的3次 +c的3次方 成立时，称n 为三位水仙花数。
输入描述
输入一个整数n(100<n≤ 999)
输出描述
输出 YES 或 NO，表示n 是否为三位水仙花数。

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();

        // 提取百位、十位和个位
        int a = n / 100;        // 百位
        int b = (n / 10) % 10;  // 十位
        int c = n % 10;         // 个位

        int sum = a * a * a + b * b * b + c * c * c;

        if (sum == n) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
        }

        scanner.close();
    }
}
```
游游手上有一个被污染的符文，这个符文上刻着一个长度为n 的字符串s(仅由大小写英文字母构成，下标从1开始)。为了清除污染，将依次执行如下两步操作: 先从左到右(按下标从小到大)依次处理每个位置i上的字符 si;

+ 若 si为小写字母，则将si替换为其在字母表中的循环前驱;特别地，'a’的循环前驱为'z’; 
+ 若 si为大写字母，则将 si替换为其在字母表中的循环后继;特别地，Z的循环后继为'A’。

在完成上述所有替换后，再从右到左(按下标从大到小)依次处理每个位置之上的字符 si：

+ 若si不是当前最新字符串的最后一个字符，且在当前最新字符串中它右侧紧邻的那个字符与si为同字母异大小写，则删除si
+ 每次删除后，剩余字符按原有先后顺序连接，继续上述判断，直至处理完毕

请输出最后的字符串

> 输入描述

第一行输入一个整数，表示字符串的长度。

第二行输入一个长度为n的字符串s

> 输出描述

输出一个字符串

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();  // 读取字符串长度
        String s = scanner.next();  // 读取字符串本体
        scanner.close();

		StringBuilder result = new StringBuilder();
		for (int i = news.length() - 1; i >= 0; i--) {
		    char curr = news.charAt(i);
		    if (result.length() > 0) {
		        char right = result.charAt(0);  // 当前字符右边的字符
		        if (Character.toLowerCase(curr) == Character.toLowerCase(right)
		                && Character.isLowerCase(curr) != Character.isUpperCase(right)) {
		            continue; // 不加入，表示删除当前字符
		        }
		    }
		    result.insert(0, curr); // 插入最前面
		}
		System.out.println(result.toString());
```
给定一个由n 个非负整数构成的数组{a1,a2,...,an}。你可以进行以下操作任意次(可以不执行任何操作)：

+ 选择一个当前在数组中的数x，对数组中所有元素执行按位异或运算

你的目标是使操作后数组中所有元素之和最大化，输出该最大值。

> 输入：

第一行T 表示T组数据，然后每组数据第一行表示数组大小，第二行是数组元素

> 输出

最大值

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int[] original = new int[n];
        for (int i = 0; i < n; i++) {
            original[i] = sc.nextInt();
        }

        int minInversions = countInversions(original); // 不操作时的逆序对数量

        // 枚举所有可能的反转区间 [l, r]
        for (int l = 0; l < n; l++) {
            for (int r = l; r < n; r++) {
                int[] temp = original.clone();
                reverse(temp, l, r);
                int currentInv = countInversions(temp);
                minInversions = Math.min(minInversions, currentInv);
            }
        }

        System.out.println(minInversions);
    }

    // 反转数组中下标从 l 到 r 的部分
    static void reverse(int[] arr, int l, int r) {
        while (l < r) {
            int temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;
            l++;
            r--;
        }
    }

    // 暴力统计逆序对数量（O(n^2)）
    static int countInversions(int[] arr) {
        int count = 0;
        int n = arr.length;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (arr[i] > arr[j]) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

给定一个长度为n的整数数组a={a1,a2,...,an}。你可以进行至多一次操作:选择一个区间[l, r]并将该区间内的元素顺序反转；也可以不进行任何操作。记逆序对为满足`1≤i<j≤n`且`ai>aj`的有序对数量(相等不计入逆序)。请你在允许至多一次区间反转的前提下,使逆序对数量尽可能小,并输出该最小值。

+ 顺序反转的定义:选择[l, r]后,将段内顺序由[al,al+1,...,ar]变为(ar,ar-1,...,al];区间外元素及其相对顺序不变。若l=r等价于不操作。

> 输入描述

第一行输入一个整数 `n(1≤n≤2x10^3)`
第二行输入n个整数 a1,a2,...,an (`1≤ai≤10^9`)

> 输出描述

输出一个整数,表示在至多一次区间反转后,数组可能达到的最小逆序对数量。
