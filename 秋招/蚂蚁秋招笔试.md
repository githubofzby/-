# 算法题1
有一个长度为 n、仅由小写字母组成的字符串 s。为了便于携带，将字符串s压缩为长度为 m、仅由大小写字母组成的字符串 t解压缩满足如下规则(从左到右处理 t)
+ 若当前字符为小写字母'x’，则在还原串s的末尾追加一次小写字母'x’;
+ 若当前字符为某个大写字母'X’，设其所在的极大连续段为区间[l, r],(即t_l =···≡ t_r ≡'X’，且t_l-1 ≠'X'\t_r+1 ≠'X’，越界时忽略)，令该段长度为k≡r-l+1，则在还原串 s的末尾追加 2的k次对应的小写字母'x’，随后整体跳过这一段继续处理；
压缩前后不同字符出现的相对顺序保持不变。给定压缩后的字符串t，请输出压缩前的字符串 8。
输入描述：
第一行输入一个整数
m(1≦m≤2x105)，表示字符串t的长度。
第二行输入一个长度为 m 的字符串 t，仅由大小写英文字母组成。
保证还原得到的字符串s的长度 n 满足1≤n≤2x10^6.
输出描述
在一行上输出长度为 n、仅由小写字母组成的字符串 s。
示例 1
输入
5
aBBcD
输出
abbbbcdd

解题思路:

1. 遍历压缩后的字符串 t,对于每个字符进行处理。
2. 如果当前字符是小写字母,直接将其追加到还原后的字符串 s 的末尾。
3. 如果当前字符是大写字母,找到其所在的极大连续段,计算该段的长度 k,然后在还原后的字符串 s 的末尾追加 2^k 个对应的小写字母。
4. 继续处理下一个字符,直到遍历完整个字符串 t。

```java
import java.util.Scanner;

public class StringDecompression {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        String t = scanner.next();
        
        String s = decompress(t);
        System.out.println(s);
    }
    
    private static String decompress(String t) {
        StringBuilder sb = new StringBuilder();
        int n = t.length();
        
        for (int i = 0; i < n; i++) {
            char c = t.charAt(i);
            
            if (Character.isLowerCase(c)) {
                sb.append(c);
            } else {
                int j = i;
                while (j < n && t.charAt(j) == c) {
                    j++;
                }
                int k = j - i;
                int count = 1 << k;  // 计算 2^k
                char lowercaseChar = Character.toLowerCase(c);
                for (int p = 0; p < count; p++) {
                    sb.append(lowercaseChar);
                }
                i = j - 1;
            }
        }
        
        return sb.toString();
    }
}
```

# 算法题2
给定一个长度为n 的数组{a1,a2,..,an}，请你计算其中所有子数组中，元素互不相同的子数组个数。
子数组指从原数组中连续选择的一段元素所形成的数组，要求非空。
输入描述
第一行输入一个整数n(1≦n≤2x10^5)，表示数组长度。
第二行输入n个整数a1,a2,...,an(1 ≤ ai ≤n)，表示数组中的元素。
输出描述
输出一个整数，表示满足条件的子数组个数。
示例：
输入
3
1 2 1
输出：5
说明
+ 所有子数组共 3x4/2=6个:[1,1]={1} 合法;[1,2]={1,2} 合法;[1,3]={1,2,1}存在重复 1，不合法;[2,2]={2} 合法;[2,3]={2,1}合法;[3,3]={1} 合法。
+ 合法子数组共有5 个，故答案为 5.
思路：
- 我们使用一个布尔数组 `seen` 来记录当前窗口中已经出现过的元素。
- 对于数组中的每个位置 `right`，我们找到最左边的位置 `left`，使得从 `left` 到 `right` 之间的所有元素互不相同。
- 然后，我们计算以 `right` 结尾且元素互不相同的子数组个数，这等于 `(right - left + 1)`。
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        
        System.out.println(countUniqueSubarrays(nums));
        scanner.close();
    }
    
    public static long countUniqueSubarrays(int[] nums) {
        int n = nums.length;
        boolean[] seen = new boolean[n + 1]; // 因为元素值在1到n之间
        long count = 0;
        int left = 0;
        
        for (int right = 0; right < n; right++) {
            // 如果当前元素已经在窗口中，移动左指针直到去除重复元素
            while (seen[nums[right]]) {
                seen[nums[left]] = false;
                left++;
            }
            
            // 标记当前元素为已见过
            seen[nums[right]] = true;
            
            // 以right结尾的不含重复元素的子数组个数等于当前窗口大小
            count += (right - left + 1);
        }
        
        return count;
    }
}
```

```java
public static int countSubArrayNum(int[] nums) {
    int n = nums.length;
    int res = 0;
    int left = 0;
    
    // 使用数组而不是HashSet来记录元素，因为题目说元素值在1到n之间
    // 这比HashSet更快
    int[] lastSeen = new int[n + 1];
    // 初始化为-1，表示元素尚未出现
    for (int i = 0; i <= n; i++) {
        lastSeen[i] = -1;
    }
    
    for (int right = 0; right < n; right++) {
        // 如果元素已在当前窗口中出现过，更新左指针
        if (lastSeen[nums[right]] >= left) {
            left = lastSeen[nums[right]] + 1;
        }
        
        // 更新元素最后出现的位置
        lastSeen[nums[right]] = right;
        
        // 计算以right结尾的所有不含重复元素的子数组数量
        res += (right - left + 1);
    }
    
    return res;
}
```

# 算法题3
有一个长度为 n 的数组 a。你可以将a 任意重排，得到一个新的数组，我们称之为a'。定义一个长度为n 的数组 b，其中b_i = MEX(a'_1,a'_2,……,a'_i)。你需要最大化数组b中的元素之和。
你需要输出最大的元素和，以及有多少种可能的重排 a，使得b中的元素和最大化。由于重排方案数可能很大，你只需要输出其对998244353 取模后的结果
【名词解释】
MEX:整数数组的 MEX 定义为没有出现在数组中的最小非负整数。例如MEX{1,2,3}=0，MEX{0,2,5}= 1.
输入描述
第一行输入一个整数n(1≤n < 2·105)，表示数组 a 的长度,第二行输入 n 个整数a1,a2,···,an(0 ≤ ai≤ 10^9)，表示数组a 的元素。
输出描述
一行输出两个整数，表示b的元素和以及 a的重排数量对 998244353 取模后的结果。
示例 1
输入 
3
1 0 1
输出
5 1
说明
将a重排为{0,1,1}后，数组b为{1,2,2}，元素和为 5。可以证明不存在一个重排使得数组b的元素和大于 5，且仅有这一种重排方案满足条件。