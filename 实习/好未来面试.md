# 第一题

给定一个字符串 s，请编写一个函数来进行基本的字符串压缩。利用字符重复出现的次数，如果压缩后的字符串没有变短，则返回原先的字符串。

```java
public class StringCompression {
    public static String compress(String s) {
        // 处理边界情况
        if (s == null || s.length() <= 1) {
            return s;
        }
        StringBuilder compressed = new StringBuilder();
        char currentChar = s.charAt(0);
        int count = 1;
        // 遍历字符串，统计连续字符出现的次数
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == currentChar) {
                // 如果当前字符与前一个相同，计数加一
                count++;
            } else {
                // 如果不同，将前一个字符及其出现次数加入结果
                compressed.append(currentChar).append(count);
                // 重置当前字符和计数
                currentChar = s.charAt(i);
                count = 1;
            }
        }
        // 处理最后一组字符
        compressed.append(currentChar).append(count);
        
        // 如果压缩后的字符串没有变短，返回原字符串
        return compressed.length() < s.length() ? compressed.toString() : s;
    }
    
    public static void main(String[] args) {
        // 测试用例
        System.out.println(compress("aabcccccaaa")); // 应输出 "a2b1c5a3"
        System.out.println(compress("abcdef"));      // 应输出 "abcdef"（因为压缩后没有变短）
        System.out.println(compress("aabb"));        // 应输出 "aabb"（因为压缩后没有变短）
        System.out.println(compress("a"));           // 应输出 "a"
        System.out.println(compress(""));            // 应输出 ""
    }
}
```

# 第二题

编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串""。(所有输入只包含小写字母 a-z)

```java
public class LongestCommonPrefix {
    public static String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        // 以第一个字符串作为初始前缀
        String prefix = strs[0];
        
        // 从第二个字符串开始，逐个比较并更新前缀
        for (int i = 1; i < strs.length; i++) {
            // 当前字符串与前缀不匹配时，缩短前缀
            while (strs[i].indexOf(prefix) != 0) {
                // 每次去掉前缀的最后一个字符
                prefix = prefix.substring(0, prefix.length() - 1);
                // 如果前缀已经为空，说明没有公共前缀
                if (prefix.isEmpty()) {
                    return "";
                }
            }
        }
        
        return prefix;
    }
    
    // 另一种实现方法：逐个字符比较
    public static String longestCommonPrefix2(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        // 以第一个字符串的长度为基准
        for (int i = 0; i < strs[0].length(); i++) {
            char c = strs[0].charAt(i);
            // 比较所有字符串的当前位置字符
            for (int j = 1; j < strs.length; j++) {
                // 如果当前字符串已经到达末尾或字符不匹配
                if (i == strs[j].length() || strs[j].charAt(i) != c) {
                    return strs[0].substring(0, i);
                }
            }
        }
        
        // 如果循环结束，说明第一个字符串就是公共前缀
        return strs[0];
    }
    
    public static void main(String[] args) {
        // 测试用例
        String[] test1 = {"flower", "flow", "flight"};
        System.out.println("最长公共前缀: " + longestCommonPrefix2(test1)); // 应输出 "fl"
        
        String[] test2 = {"dog", "racecar", "car"};
        System.out.println("最长公共前缀: " + longestCommonPrefix2(test2)); // 应输出 ""
        
        String[] test3 = {"apple"};
        System.out.println("最长公共前缀: " + longestCommonPrefix2(test3)); // 应输出 "apple"
        
        String[] test4 = {};
        System.out.println("最长公共前缀: " + longestCommonPrefix2(test4)); // 应输出 ""
        
        String[] test5 = {"c", "c"};
        System.out.println("最长公共前缀: " + longestCommonPrefix2(test5)); // 应输出 "c"
    }
}
```

