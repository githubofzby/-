# 华为笔试题

## 第一题

一个超大智能汽车测试场有多个充电桩，每个充电桩的位置由其在二维平面上的坐标 (x,y)  表示。给定一辆智能汽车的当前位置(car_x,car_y)，请设计一个高效的算法，找出给定智能汽车行驶到充电桩行驶距离最近的k个充电桩并输出相关充电桩信息(编号、坐标、行驶距离)，且按行驶距离升序排序(最近行驶距离的排在最前面)，如果存在行驶距离相等的充电桩则按照充电桩的编号从小到大输出。汽车到充电桩的行驶距离的计算方法为abs(car_x-x) + abs(car_y-y)注意: abs表示绝对值。 解答要求 时间限制:C/C++ 1000ms,其他语言:2000ms内存限制:C/C++256MB，其他语言:512MB 输入 1，第一行是2个整数kn，空格间隔，第1个整数k表示需要输出到的行驶距离最近的充电桩的数量(0<=k<=1000000)，第2个整数n表示充电桩的总数量(0< n<= 1000000). 当前位置坐标。 2，第2行是长度为2的整数数组car_x car_y,中间是空格间隔，表示智能汽车的 3，第3行到第n+2行易编号为1到n的充电桩的位置坐标. 注意:坐标数值大小区间为:[-2^32,2^31-1] 输出	 一个二维数组，每一行是一个长度为4的数组:编号x y  distance,编号表示充电桩的编号(介于1到n之间)、xy表示充电桩的坐标,distance表示智能汽车到充电桩的行驶距离，从第1行开始往下是按距离从小到大排序的。如果存在行驶距离相等的充电桩则按照充电桩的编号从小到大输出。如果k为0或者k大于n,输出字符串null.

```java
import java.util.*;

public class Main {
    static class ChargingStation implements Comparable<ChargingStation> {
        int id;
        long x;
        long y;
        long distance;
        
        public ChargingStation(int id, long x, long y, long distance) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.distance = distance;
        }
        
        @Override  
        public int compareTo(ChargingStation other) {
            if (this.distance != other.distance) {
                return Long.compare(this.distance, other.distance);
            }
            return Integer.compare(this.id, other.id);
        }
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int k = scanner.nextInt();
        int n = scanner.nextInt();
        
        long car_x = scanner.nextLong();
        long car_y = scanner.nextLong();
        
        if (k == 0 || k > n) {
            System.out.println("null");
            return;
        }
        
        List<ChargingStation> stations = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            long x = scanner.nextLong();
            long y = scanner.nextLong();
            long distance = Math.abs(car_x - x) + Math.abs(car_y - y);
            stations.add(new ChargingStation(i+1, x, y, distance));
        }
        
        Collections.sort(stations);
        
        for (int i = 0; i < k; i++) {
            ChargingStation station = stations.get(i);
            System.out.println(station.id + " " + station.x + " " + station.y + " " + station.distance);
        }
        
        scanner.close();
    }
}
```

## 第二题

有一棵二叉树，每个节点上都住了一户居民。现在要给这棵树上的居民建设基站，每个基站只能覆盖她所在与相邻的节点，请问信号覆盖这棵树最少需要建设多少个基站
解答要求
时间限制:C/C++ 1000ms,其他语言:2000ms内存限制:C/C++ 256MB，其他语言:512MB
输入
一个整数数组 nums(1<=num.ength<=3000)，用空格分隔，表示二叉树的节点值，正整数表示存在节点，N表示不存在节点，如[1 2 3 4 N 5 6]表示的树，最少需要建设2个基站
输出 
最小建设基站的个数

示例：

输入：1 2 N 3 N N 4
输出：2

> deepsek牛逼哦

```java
import java.util.*;

public class Main {
    static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        
        TreeNode(int val) {
            this.val = val;
        }
    }
    
    static class Result {
        int coveredWithCam; // 当前节点安装基站
        int coveredByChild; // 当前节点被覆盖（由子节点覆盖）
        int notCovered;     // 当前节点未被覆盖
        
        Result(int a, int b, int c) {
            coveredWithCam = a;
            coveredByChild = b;
            notCovered = c;
        }
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] input = scanner.nextLine().split(" ");
        
        TreeNode root = buildTree(input);
        
        Result result = dfs(root);
        
        System.out.println(Math.min(result.coveredWithCam, Math.min(result.coveredByChild, result.notCovered + 1)));
    }
    
    private static TreeNode buildTree(String[] values) {
        if (values.length == 0 || values[0].equals("N")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(values[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int i = 1;
        while (!queue.isEmpty() && i < values.length) {
            TreeNode node = queue.poll();
            if (i < values.length && !values[i].equals("N")) {
                node.left = new TreeNode(Integer.parseInt(values[i]));
                queue.add(node.left);
            }
            i++;
            if (i < values.length && !values[i].equals("N")) {
                node.right = new TreeNode(Integer.parseInt(values[i]));
                queue.add(node.right);
            }
            i++;
        }
        return root;   // 在循环外面
    }
    
    private static Result dfs(TreeNode node) {
        if (node == null) {
            return new Result(Integer.MAX_VALUE/2, 0, 0);
        }
        Result left = dfs(node.left);
        Result right = dfs(node.right);
        
        int cam = 1 + Math.min(left.coveredWithCam, Math.min(left.coveredByChild, left.notCovered)) 
                     + Math.min(right.coveredWithCam, Math.min(right.coveredByChild, right.notCovered));
        // coveredWithCam 是 strong
        int byChild = Math.min(left.coveredWithCam + Math.min(right.coveredWithCam, right.coveredByChild),
                             right.coveredWithCam + Math.min(left.coveredWithCam, left.coveredByChild));
        
        int notCovered = left.coveredByChild + right.coveredByChild;
        
        return new Result(cam, byChild, notCovered);
    }
}
```

chatgpt，示例是对的 我试一下示例2   示例1 结果也是2 吗

```java
import java.util.*;

public class Main {
    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int v) {
            val = v;
        }
    }

    static int cameraCount = 0;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        List<String> input = new ArrayList<>();
        while (sc.hasNext()) {
            input.add(sc.next());
        }
        TreeNode root = buildTree(input);
        int state = postOrder(root);
        if (state == 0) cameraCount++; // 根节点没被覆盖时加一个
        System.out.println(cameraCount);
    }

    // 构建树
    public static TreeNode buildTree(List<String> nodes) {
        if (nodes == null || nodes.size() == 0 || nodes.get(0).equals("N")) return null;
        TreeNode root = new TreeNode(Integer.parseInt(nodes.get(0)));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int i = 1;
        while (!queue.isEmpty() && i < nodes.size()) {
            TreeNode current = queue.poll();
            // 左节点
            if (i < nodes.size() && !nodes.get(i).equals("N")) {
                current.left = new TreeNode(Integer.parseInt(nodes.get(i)));
                queue.add(current.left);
            }
            i++;
            // 右节点
            if (i < nodes.size() && !nodes.get(i).equals("N")) {
                current.right = new TreeNode(Integer.parseInt(nodes.get(i)));
                queue.add(current.right);
            }
            i++;
        }
        return root;
    }

    // 后序遍历并决定放置基站
    // 返回状态：0 = 未覆盖，1 = 已覆盖，2 = 有基站
    public static int postOrder(TreeNode node) {
        if (node == null) return 1; // 空节点当作已覆盖
        int left = postOrder(node.left);
        int right = postOrder(node.right);

        if (left == 0 || right == 0) {
            cameraCount++;
            return 2;
        }
        if (left == 2 || right == 2) {
            return 1;
        }
        return 0;
    }
}
```

这题ac两道都感觉不错了

## 第三题

最小代价相遇的路径规划 假定有两辆车在给定一个nxn的非负整数矩阵地图grid中行驶，地图左上角位置为[0,0]。我们简化车辆行驶的方式，每辆车可以从一个坐标行驶到相邻(上下左右)的另一个坐标，并且经过的每个位置都会产生代价，包括起始位置的代价。其中grid[i]0]表示通过网格位置[,j]所需的代价。矩阵中，grid[i]等于0表示该位置为障碍物，车辆无法通过。两辆车约定好需要在地图中快速相遇进行货物交接。 两辆车相遇的定义为:两辆车最终分别停在相邻的网格位置(上下或左右相邻)，并且路径可达。 两辆车相遇所需的代价定义为:两辆车到达各自相遇位置所需代价中的较大值。注意:路径代价包含车辆的起始位置位置的代价;行驶过程中，车辆可以停在某一个网格位置上，两辆车无需同步行驶。 求两辆车可以相遇需要的最小代价，如果无法相遇则返回-1. 解答要求 时间限制:C/C++ 1000ms,其他语言:2000ms 内存限制:C/C++256MB，其他语言:512MB 输入 第一行输入是一个整数n，代表地图grid[n][n] 的大小，即n行n列大小的地图。 后续每一行代表地图中通过每个网格位置所需的时间信息，即grid[n][n]的每一行的元素值 假设初始状态两辆车分别从左上角[0,0]和右下角[n-1,n-1]出发,左上角的车只能向右或向下移动，右下角的车只能向上或向左移动。参数取值范围:`2 <=n<=10000 <=grid[i][j]<=100 grid[0][0]!=0 grid[n-1][n-1]  !=0 `输出 一个整数，表示两辆车相遇的最小代价;如果两车无法相遇(例如都被障碍物阻挡)，则返回-1











