# 算法题1

你有一个容量为T的背包，最多能携带总重量不超过T的物品。 迷宫中共有 M 件宝物，每件宝物都有自己的重量和价值,你只能选择带走其中的一部分，而且每件宝物最多只能带走一次(不能拆分也不能重复拿取)。 在不超重的前提下，请问背包中物品的总价值最大是多少? 

输入描述 第一行有两个整数T和M，分别表示背包的承重上限和宝物的数量。接下来 M 行，每行包含两个在1到100之间(包括1和100)的整数，分别表示每个宝物的重量和价值。 

输出描述 输出一行整数，表示在不超过背包承重的前提下所能获得的最大总价值

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // 输入 T 和 M
        int T = sc.nextInt(); // 背包承重上限
        int M = sc.nextInt(); // 宝物数量

        int[] w = new int[M + 1]; // 重量数组
        int[] v = new int[M + 1]; // 价值数组

        for (int i = 1; i <= M; i++) {
            w[i] = sc.nextInt();
            v[i] = sc.nextInt();
        }

        // 动态规划数组
        int[] dp = new int[T + 1];

        // 0/1 背包：每件物品最多只能取一次
        for (int i = 1; i <= M; i++) {        // 遍历每件物品
            for (int j = T; j >= w[i]; j--) { // 倒序遍历容量，避免重复使用同一物品
                dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);
            }
        }

        // 输出结果：最大价值
        System.out.println(dp[T]);
    }
}

```

# 算法题2

在一个长达10的18次单位长度的直线道路上安装了N盏特殊路灯。每盖路灯的位置按从左到右依次为 A1<A2<…
<An。
我们定义某个位置x的“黑暗程度”为该位置到所有路灯之间距离的最小值。即，黑暗程度等于数列|A1-x|,|A2-x|…|An-x|中的最小值。例如，下表是一个三盏路灯分别分布在1、4、8三个位置时位置0至10的黑暗程度。

| 位置x    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 黑暗程度 | 1    | 0    | 1    | 1    | 0    | 1    | 2    | 1    | 2    | 1    | 2    |
| 是否有灯 |      | 1    |      |      | 1    |      |      |      | 1    |      |      |

为了更好地研究城市的照明情况，我们需要找出从位置x=0到x=L这L+1个整数位置中，黑暗程度最小的K个值并按照从小到大的顺序输出。

输入描述
第一行输入三个整数L,N,K，用空格隔开。第二行输入N个整数 A1,A2.…An，表示每盖路灯的位置，以空格分隔
输出描述
输出K行，第i行输出从小到大排序后的第i小黑暗程度值。

```java
import java.util.*;

public class Main {
    static long L;
    static int N, K;
    static long[] A;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        L = sc.nextLong(); 
        N = sc.nextInt(); 
        K = sc.nextInt(); 

        A = new long[N];
        for (int i = 0; i < N; i++) {
            A[i] = sc.nextLong();
        }
        Arrays.sort(A);

        // 用 TreeSet 收集所有候选值
        TreeSet<Long> candidates = new TreeSet<>();
        candidates.add(0L);

        // 左端
        candidates.add(A[0]);
        // 右端
        candidates.add(L - A[N - 1]);
        // 相邻路灯间隔
        for (int i = 0; i < N - 1; i++) {
            long dist = A[i + 1] - A[i];
            candidates.add(dist / 2);
            candidates.add((dist + 1) / 2); // 取整时可能差 1
        }

        // 把候选值放进列表
        List<Long> list = new ArrayList<>(candidates);
        Collections.sort(list);

        // 输出前 K 个
        for (int i = 0; i < K && i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
}

```











