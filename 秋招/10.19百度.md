# 算法题1

有一个长度为 n 的数组 {a1,  a2, ... ,an};
为了让数组最大值不超过最小值的两倍，即`max(a1,...,an)<2*min(a1,...,an)`，他可以进行以下操作多次，直到满足条件:

+ 选择一个元素 ai，并选取两个正整数x,y满足 x+ y≡ ai，将 ai 删除，并将x,y插入数组。

请你计算使数组变为令人心动所需的最少操作次数。

输入描述:

第一行输入一个整数n，表示数组的长度;第二行输入n个整数a1,a2, … ,an，表示数组中的元素。

输出最少操作次数

示例：

```
3
3 6 13
```

输出 `2`

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        
        List<Integer> nums = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            nums.add(scanner.nextInt());
        }
        
        // BFS：队列存储 [数组状态, 操作次数]
        Queue<Object[]> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        
        queue.offer(new Object[]{nums, 0});
        visited.add(getKey(nums));
        
        while (!queue.isEmpty()) {
            Object[] current = queue.poll();
            List<Integer> currentNums = (List<Integer>) current[0];
            int operations = (int) current[1];
            
            // 检查是否满足条件
            int min = Collections.min(currentNums);
            int max = Collections.max(currentNums);
            
            if (max <= 2 * min) {
                System.out.println(operations);
                return;
            }
            
            // 拆分最大值
            int maxIdx = currentNums.indexOf(max);
            
            // 尝试不同的拆分方式
            for (int x = 1; x < max; x++) {
                int y = max - x;
                
                List<Integer> newNums = new ArrayList<>(currentNums);
                newNums.remove(maxIdx);
                newNums.add(x);
                newNums.add(y);
                
                String key = getKey(newNums);
                
                if (!visited.contains(key)) {
                    visited.add(key);
                    queue.offer(new Object[]{newNums, operations + 1});
                }
            }
        }
        
        System.out.println(0);
        scanner.close();
    }
    
    // 生成数组的唯一标识（用于去重）
    static String getKey(List<Integer> nums) {
        List<Integer> sorted = new ArrayList<>(nums);
        Collections.sort(sorted);
        return sorted.toString();
    }
}
```





# 算法题2

给定一个仅包含数字字符的字符串s，长度为 n。又给定一个偶数 k，满足 2≤k≤ n
我们称字符串s中所有长度为k的子串为幸运子串，当且仅当该子串的前 k/2 个字符对应的数字之和等于后k/2 个字符对应的数字之和。

请计算并输出字符串s中幸运子串的总数

输入描述：

每个测试文件均包含多组测试数据。第一行输入一个整数t代表测试用例数。
每组测试数据描述如下:

+ 在一行上输入两个整数n,k; k为偶数
+ 在一行上输入一个长度为 n、仅由数字字符"0"到"9"构成的字符串s。

除此之外，保证所有测试用例n的总和不超过10^6。

输出：

对于每个测试用例，新起一行，输出一个整数，表示字符串s中幸运子串的数量

示例：

```
2
4 2
1122
6 4
121212
```

输出：

```
2
3
```



```java
import java.util.Scanner;

public class LuckySubstring {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); // 测试用例数
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            String s = sc.next();
            
            int[] prefixSum = new int[n + 1]; // 前缀和数组
            for (int i = 0; i < n; i++) {
                prefixSum[i + 1] = prefixSum[i] + (s.charAt(i) - '0');
            }
            
            int count = 0;
            int half = k / 2;
            for (int i = 0; i <= n - k; i++) {
                int sum1 = prefixSum[i + half] - prefixSum[i];         // 前 k/2 个字符和
                int sum2 = prefixSum[i + k] - prefixSum[i + half];     // 后 k/2 个字符和
                if (sum1 == sum2) {
                    count++;
                }
            }
            System.out.println(count);
        }
        sc.close();
    }
}

```

# 算法题3

给定一个偶数长度的二进制字符串 \( s \)（长度记为 \( n \)，下标从 1 开始），以及两个整数 \( m \) 与 \( k \)。

对于每个下标 \( i \)（\( 1 <= i <= n - i + 1 \)），定义其对称下标为：$j = n - i + 1$

若 $ s_i = s_{n-i+1}$ ，则称 \((i,n-i+1)\) 为一个 好对。

---

你可以 一次性选择最多 \( m \) 个下标，将选中的字符全部翻转 。

请计算：  
共有多少种翻转方案可以使最终字符串中恰好拥有 \( k \) 个好对？

两种方案视为不同，当且仅当它们翻转的下标集合不同。

输入：

每个测试文件均包含多组测试数据。  

- 第一行输入一个整数 $$T$$（$$1 \le T \le 100$$），表示数据组数。  
- 每组测试数据描述如下：  
  1. 第一行输入三个整数：
     $$
     n, m, k \quad (2 \le n \le 60;\ 0 \le m \le n;\ 0 \le k \le n/2)
     $$
     分别表示字符串长度、翻转次数上限、好对数量目标。
  2. 第二行输入一个长度为 $$n$$ 的二进制字符串 $$S$$。  

除此之外，保证单个测试文件中所有字符串长度之和不超过 600。

输出：

对于每组测试数据，在一行上输出一个整数，表示满足条件的翻转方案数量对 $$10^9 + 7$$ 取模后的结果。