```java
/**
 * 对称二叉树 - 判断一棵二叉树是否是镜像对称的

    TreeNode类：定义了二叉树的节点结构，包含值和左右子节点指针。

    isSymmetric方法：检查一棵树是否对称，通过调用isMirror方法比较左右子树。

    isMirror方法：递归判断两棵树是否互为镜像，需要满足三个条件：
        两个节点的值相等
        第一棵树的左子树与第二棵树的右子树互为镜像
        第一棵树的右子树与第二棵树的左子树互为镜像

    createBinaryTree方法：辅助方法，从数组创建二叉树用于测试。

    main方法：包含两个示例，一个对称的二叉树和一个非对称的二叉树，展示算法的运行结果。

 */
public class SymmetricTree {
    
    // 二叉树节点的定义
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        
        TreeNode(int val) {
            this.val = val;
        }
    }
    
    /**
     * 判断二叉树是否对称
     * @param root 二叉树根节点
     * @return 如果对称返回true，否则返回false
     */
    public static boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 检查左右子树是否互为镜像
        return isMirror(root.left, root.right);
    }
    
    /**
     * 判断两棵树是否互为镜像
     * @param left 第一棵树
     * @param right 第二棵树
     * @return 如果互为镜像返回true，否则返回false
     */
    private static boolean isMirror(TreeNode left, TreeNode right) {
        // 两棵树都为空，视为对称
        if (left == null && right == null) {
            return true;
        }
        // 如果只有一棵树为空，则不对称
        if (left == null || right == null) return false;
        // 判断条件：1.根节点值相同 2.left的左子树与right的右子树对称 3.left的右子树与right的左子树对称  
        return (left.val == right.val) && isMirror(left.left, right.right) && 
               isMirror(left.right, right.left);
    }
    
    /**
     * 构建示例树的辅助方法 - 根据数组创建一棵二叉树
     * @param array 层序遍历的数组表示，null表示空节点
     * @return 创建的二叉树根节点
     */
    public static TreeNode createBinaryTree(Integer[] array) {
        if (array == null || array.length == 0 || array[0] == null) {
            return null;
        }
        
        TreeNode root = new TreeNode(array[0]);
        java.util.Queue<TreeNode> queue = new java.util.LinkedList<>();
        queue.offer(root);
        
        int i = 1;
        while (!queue.isEmpty() && i < array.length) {
            TreeNode node = queue.poll();
            
            // 添加左子节点
            if (i < array.length && array[i] != null) {
                node.left = new TreeNode(array[i]);
                queue.offer(node.left);
            }
            i++;
            // 添加右子节点
            if (i < array.length && array[i] != null) {
                node.right = new TreeNode(array[i]);
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }
    
    /**
     * 主函数，包含示例
     */
    public static void main(String[] args) {
        // 示例1: [1,2,2,3,4,4,3] - 对称二叉树
        System.out.println("示例1:");
        Integer[] array1 = {1, 2, 2, 3, 4, 4, 3};
        TreeNode root1 = createBinaryTree(array1);
        System.out.println("输入: [1,2,2,3,4,4,3]");
        System.out.println("输出: " + isSymmetric(root1));
        System.out.println("解释: 这是一个对称的二叉树");
        System.out.println();
        
        // 示例2: [1,2,2,null,3,null,3] - 非对称二叉树  
        System.out.println("示例2:");
        Integer[] array2 = {1, 2, 2, null, 3, null, 3};
        TreeNode root2 = createBinaryTree(array2);
        System.out.println("输入: [1,2,2,null,3,null,3]");
        System.out.println("输出: " + isSymmetric(root2));
        System.out.println("解释: 这不是一个对称的二叉树");
    }
}
```



```java
/*
    首先处理边界条件：
        当 n < 0 时，返回0（无法达到）
        当 n = 0 时，返回1（已经在起点，视为1种方法）
        当 n = 1 时，返回1（只能跳1步）
        当 n = 2 时，返回1（只能跳两次1步）

    创建一个长度为 n+1 的数组存储中间结果。

    从 i=3 开始计算每个台阶的跳法数量：dp[i] = dp[i-1] + dp[i-3]。
    
    猴子跳上5个台阶共有4种不同的跳法：

    1步 + 1步 + 1步 + 1步 + 1步
    1步 + 1步 + 3步
    1步 + 3步 + 1步
    3步 + 1步 + 1步


*/
public class MonkeyJump {
    // 动态规划问题
    public static int countWays(int n) {
        if (n < 0)  return 0;
        if (n == 0) return 1;
        if (n == 1) return 1;
        if (n == 2) return 1;                   
        // 创建动态规划数组
        int[] dp = new int[n + 1];
        // 设置初始条件
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 1;
        // 应用递推公式
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 3];
        }
        return dp[n];
    }
    
    public static void main(String[] args) {
        // 示例验证
        int n = 5;
        int result = countWays(n);
        System.out.println("猴子跳上" + n + "个台阶的不同跳法数量为：" + result);
        
        // 多一些测试用例
        System.out.println("n=1: " + countWays(1));  // 1
        System.out.println("n=2: " + countWays(2));  // 1
        System.out.println("n=3: " + countWays(3));  // 2
        System.out.println("n=4: " + countWays(4));  // 3
        System.out.println("n=5: " + countWays(5));  // 4
        System.out.println("n=10: " + countWays(10)); // 41
    }
}
```















