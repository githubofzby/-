# 网易互娱笔试题

## 第一题

一个的技能释放后可以进入无敌状态，持续时间为T秒(即如果i秒释放这个技能，在[i,i+T] 秒内都是无敌状态)。在这段时间内将免疫所有伤害和控制效果。但是无敌状态结束后，技能需要经过 C秒的冷却时间才能再次释放。

给定无敌状态的持续时间 T、技能的冷却时间 C、技能释放的时间点列表(可能由于冷却时间限制，某些时间点无法释放技能)、以及击杀敌人的时间点列表，请计算单次无敌状态下的最大击杀数。

输入描述
输入的第一行为一个整数P，表示后续有独立的P组测试数据，每组数据包括三行，其中:

+ 第一行包含四个整数，分别为无敌状态的持续时间T(1<=T<=1000)、技能的冷却时间C(1≤C<=1000)、技能释放的时间点列表的长度N(1<=N<=100000)，以及击杀敌人的时间点列表的长度M(1≤M≤100000).
+ 第二行包含N个整数，表示技能释放的时间点列表，按升序排列。
+ 第三行包含M个整数，表示击杀敌人的时间点列表，按升序排列。
+ 所有时间点均为非负整数，且不超过10^9

输出描述

+ 对于每组数据，输出一个整数，表示单次无敌状态下的最大击杀数。

示例1:

```
输入：
1
5 10 2 10
0 15
1 2 3 4 5 6 7 8 9 10
输出：
4
```

无敌状态持续5秒，冷却时间10秒。
技能释放时间点列表为[0，15]。
击杀敌人的时间点列表为[1,2,3,4,5,6,7,8,9,10]。在时间点0释放技能，无敌状态持续时间点为[0，1，2，3，4]，期间可以击杀敌人时间点1,2,3,4，共4个敌人。
其他技能释放时间点无法覆盖更多的击杀数。

示例2:

```
输入：
1
5 10 2 7
0 6
1 4 6 7 8 9 10
输出：
2
```

在时间点0释放技能，无敌状态持续时间点为[0,1,2,3.4]，期间可以击杀敌人时间点1,4，共2个敌人。
在时间点6释放技能，由于技能仍然处于冷却状态未释放成功。后续的击杀不属于无敌状态时的击杀，无需统计。

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int P = scanner.nextInt(); // 测试用例数
        
        for (int p = 0; p < P; p++) {
            int T = scanner.nextInt(); // 无敌状态持续时间
            int C = scanner.nextInt(); // 冷却时间
            int N = scanner.nextInt(); // 技能释放时间点数量
            int M = scanner.nextInt(); // 击杀敌人时间点数量
            
            int[] skillTimes = new int[N];
            for (int i = 0; i < N; i++) {
                skillTimes[i] = scanner.nextInt();
            }
            
            int[] killTimes = new int[M];
            for (int i = 0; i < M; i++) {
                killTimes[i] = scanner.nextInt();
            }
            
            System.out.println(maxKills(T, C, skillTimes, killTimes));
        }
        scanner.close();
    }
    public static int maxKills(int T, int C, int[] skillTimes, int[] killTimes) {
        int maxKillCount = 0;
        int lastValidSkillTime = -T - C - 1; // 初始化为一个肯定不会影响第一个技能释放的时间
        
        // 遍历每个可能的技能释放时间点
        for (int i = 0; i < skillTimes.length; i++) {
            int skillTime = skillTimes[i];
            
            // 检查是否符合冷却时间限制
            if (skillTime >= lastValidSkillTime + T + C) {
                lastValidSkillTime = skillTime;
                
                // 计算无敌窗口 [skillTime, skillTime + T - 1]
                int invincibilityStart = skillTime;
                int invincibilityEnd = skillTime + T - 1;
                
                // 计算这个窗口内的击杀数
                int killCount = 0;
                for (int killTime : killTimes) {
                    if (killTime >= invincibilityStart && killTime <= invincibilityEnd) {
                        killCount++;
                    }
                    // 优化：如果已经超过窗口，可以停止计数
                    if (killTime > invincibilityEnd)  break;
                }
                
                // 更新最大击杀数
                maxKillCount = Math.max(maxKillCount, killCount);
            }
        }
        
        return maxKillCount;
    }
}
```

```java
//deepseek改  自测能过吗  能过
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int P = scanner.nextInt();
        
        for (int p = 0; p < P; p++) {
            int T = scanner.nextInt();
            int C = scanner.nextInt();
            int N = scanner.nextInt();
            int M = scanner.nextInt();
            
            int[] skillTimes = new int[N];
            for (int i = 0; i < N; i++) {
                skillTimes[i] = scanner.nextInt();
            }
            
            int[] killTimes = new int[M];
            for (int i = 0; i < M; i++) {
                killTimes[i] = scanner.nextInt();
            }
            
            System.out.println(maxKills(T, C, skillTimes, killTimes));
        }
        scanner.close();
    }

    public static int maxKills(int T, int C, int[] skillTimes, int[] killTimes) {
        int maxKillCount = 0;
        long lastValidSkillTime = Long.MIN_VALUE; // 初始化为极小值，感觉应该不用极小值 
        List<Integer> validSkills = new ArrayList<>();

        // 筛选有效的技能释放时间点（考虑冷却时间）
        for (int s : skillTimes) {
            if (s >= lastValidSkillTime) {
                validSkills.add(s);
                lastValidSkillTime = s + T + C; // 下一个有效时间必须 >= 当前时间 + T + C
            }
        }

        // 遍历每个有效技能时间点，用二分查找计算击杀数
        for (int s : validSkills) {
            int start = s;
            int end = s + T; // 无敌时间段为 [start, end)
            // 找到第一个 >= start 的位置
            int left = lowerBound(killTimes, start);
            // 找到第一个 >= end 的位置
            int right = lowerBound(killTimes, end);
            maxKillCount = Math.max(maxKillCount, right - left);
        }
        return maxKillCount;
    }
    // 二分查找下界（第一个 >= target 的位置）
    private static int lowerBound(int[] arr, int target) {
        int low = 0, high = arr.length;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] >= target) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
}
```

## 第二题

小易需要编写一个算法，统计每个像素中被给定三角形覆盖的采样点的相关情况，以便后续的渲染处理。在渲染图像组成的平面直角坐标系中，给定一个由顶点 A、B、C构成的三角形。整个图像的每个像素，会被均匀划分为SxS个子区域，而每个子区域的中心点，都会被作为采样点，判断是否被三角形覆盖(采样点恰好位于三角边上时也认为是被覆盖)，以便进行后续计算。例如，当S=2时，每个像素内有 4个采样点。因此，每个像素中被三角形覆盖的采样点数量，最少为0个(该像素完全在三角形外)，最多为S^2个(该像素完全在三角形内)。
小易需要统计在所有的像素(共NxM个)中，被该三角形覆盖贽大的采样点数量分布情况。输出1行共 s2+1个整数，其中第i(i=0...S^2)个整数表示恰好包含i个被三角形覆盖的采样点的像素数量。

输入描述：

第一行包含三个整数 N、M、S，表示平面尺寸和超采样倍数。其中1≤N,M≤1000，1≤S≤10.接下来三行，每行两个浮点数，分别表示顶点A、B、C的坐标(x,y)。其中0≤Ax,Bx,Cx≤N，0≤ Ay, By, Cy ≤ M.

输出描述：

输出1行共 s2+1个整数，其中第i(i=0..s2)个整数表示恰好包含i个被三角形覆盖的采样点的像素数量，相邻整数用空格隔开。

示例1：

```
输入：
3 3 2
0 0 
2 0
0 2
输出：
6 0 0 2 1
```

示例2:

```
输入：
2 2 3 
0 0
1 1
0 1
输出：
3 0 0 0 0 0 1 0 0 0
```

// 第二题

```java
import java.util.*;

public class TriangleCoverageCounter {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 读取输入参数
        int N = scanner.nextInt(); // 图像宽度
        int M = scanner.nextInt(); // 图像高度
        int S = scanner.nextInt(); // 超采样倍数
        
        // 读取三角形三个顶点坐标
        double Ax = scanner.nextDouble();
        double Ay = scanner.nextDouble();
        double Bx = scanner.nextDouble();
        double By = scanner.nextDouble();
        double Cx = scanner.nextDouble();
        double Cy = scanner.nextDouble();
        
        // 计算结果并输出
        int[] result = countPixelCoverage(N, M, S, Ax, Ay, Bx, By, Cx, Cy);
        
        // 打印结果
        for (int count : result) {
            System.out.print(count + " ");
        }
    }
    
    /**
     * 统计像素覆盖情况
     */
    public static int[] countPixelCoverage(int N, int M, int S, double Ax, double Ay, double Bx, double By, double Cx, double Cy) {
        int[] coverageCount = new int[S * S + 1]; // 存储像素覆盖采样点数量的分布
        
        // 遍历所有像素
        for (int x = 0; x < N; x++) {
            for (int y = 0; y < M; y++) {
                // 计算当前像素内的采样点覆盖数量
                int coveredSamples = countCoveredSamples(x, y, S, Ax, Ay, Bx, By, Cx, Cy);
                coverageCount[coveredSamples]++;
            }
        }
        
        return coverageCount;
    }
    
    /**
     * 计算一个像素内被三角形覆盖的采样点数量
     */
    public static int countCoveredSamples(int pixelX, int pixelY, int S, double Ax, double Ay, double Bx, double By, double Cx, double Cy) {
        int covered = 0;
        double sampleSize = 1.0 / S;
        
        // 遍历像素内的所有采样点
        for (int i = 0; i < S; i++) {
            for (int j = 0; j < S; j++) {
                // 计算采样点坐标（像素坐标系）
                // 采样点位于子区域中心，所以加上0.5个子区域宽度
                double sampleX = pixelX + (i + 0.5) * sampleSize;
                double sampleY = pixelY + (j + 0.5) * sampleSize;
                
                // 判断采样点是否在三角形内
                if (isPointInTriangle(sampleX, sampleY, Ax, Ay, Bx, By, Cx, Cy)) {
                    covered++;
                }
            }
        }
        
        return covered;
    }
    
    /**
     * 检查点(x,y)是否在由A(Ax,Ay), B(Bx,By), C(Cx,Cy)构成的三角形内
     * 使用重心坐标法判断点是否在三角形内
     */
    public static boolean isPointInTriangle(double x, double y, double Ax, double Ay, double Bx, double By, double Cx, double Cy) {
        // 计算重心坐标系下的坐标
        double denominator = ((By - Cy) * (Ax - Cx) + (Cx - Bx) * (Ay - Cy));
        
        // 如果分母为0，三点共线，视为不在三角形内
        if (Math.abs(denominator) < 1e-10) {
            return false;
        }
        
        double alpha = ((By - Cy) * (x - Cx) + (Cx - Bx) * (y - Cy)) / denominator;
        double beta = ((Cy - Ay) * (x - Cx) + (Ax - Cx) * (y - Cy)) / denominator;
        double gamma = 1.0 - alpha - beta;
        
        // 判断点是否在三角形内（包括边界）
        return alpha >= 0 && beta >= 0 && gamma >= 0;
    }
}
```

## 第三题

在《蛋仔派对》的世界里，蛋仔们正欢聚一堂，准备开启一场奇妙的冒险。然而，一场突如其来的意外打破了派对的宁静。某天，X个蛋仔在参加派对时，误入了一个神秘的大小为 NxM 的迷宫。这个迷宫充满了各种障碍和陷阱，仿佛是一个巨大的挑战场。幸运的是，迷宫中还有丫个出口，蛋仔们可以通过这ペ龀荐嫣些出口逃离迷宫。
然而，逃离迷官并不容易。每个蛋仔初始时各自携带了K的能量，每次可以往上、下、左、右四个方向移动一格，每移动一格需要消耗1单位的能量，如果能量用尽后则无法移动。同时每个蛋仔都有一个特定的能量需求E，当蛋仔移动到迷宫出口时，只有迷宫的能量值达到或超过 日 时，蛋仔才能顺利逃脱，否则需要等到迷宫能量值达到 E,的时候才可以逃脱。迷宫的能量值初始为 E，每当一个蛋仔在t时刻成功逃脱后，蛋仔剩下的能量值会在下一时刻补充到迷宫的能量值中。蛋仔们每移动一格需要花费1单位时间，且同一时间只能有一个蛋仔移动。蛋仔们之间不会相互阻挡，但他们的逃脱顺序和路径选择，将直接影响所有蛋仔逃出迷宫的总时间。
恿妝戏这场充满挑战的冒险中，蛋仔们需要智慧和勇气，才能找到逃脱路径成功逃离迷宫，请帮助蛋仔们，计算出所有蛋仔都逃出所花费的最短时间。

输入描述：

输入的第一行为一个整数 P，表示后续有独立的 P组测试数据，每组数据格式如下:

+ 第一行包含五个整数 N,M,X,Y,E，分别表示迷宫的行数、列数、蛋仔数量、出口数量和迷宫的初始能量值。其中1≤N,M≤ 800,1≤X, Y≤ 800,O≤E≤ 100000.
+ 接下来X行，每行包含四个整数x;y,E,K，表示第1个蛋仔的初始位置位于第 x;列第 y 行””、逃脫所需的能量值 E, 和蛋仔初始携带的能量值K。其中1≤x≤M，1SYSN，0S E; K'S 100000.
+ 接下来Y行，每行包含两个整数p9，表示第j个出口的位置位于第p列第q行。其中1SpSM,1SqSN.
+ 接下来N行，每行包含M个字符，表示迷宫的布局。字符，表示空地，字符#表示障碍。保证所有蛋仔初始位置和迷宫出口位置均为空地，保证蛋仔初始位置不在迷宫出口上。

输出描述：

输出一个整数，表示所有蛋仔都逃出迷宫所花费的最短时间。如果无法让所有蛋仔逃脱，则输出-1。

补充说明：

注意题目中所有的坐标(x,y)均为先列后行的形式，即x为水平方向，y为竖直方向，原点在输入迷宫图的左上角，行列均从1开始计数。

示例1:

```
输入：
1
5 5 2 2 10
1 1 5 7
3 3 8 2
2 4
4 2
.....
.#...
.....
...#.
.....
输出：
6
```

说明

+ 第一个蛋仔从(1,1)移动到(2,4)需要4步，在t=4时刻逃生，逃生时蛋仔剩余能量3，迷宫能量值在t=5时刻增加到13。
+ 第二个蛋仔从(3,3)移动到(4,2)需要2步，在t=6时刻逃生，逃生时蛋仔剩余能量0，迷宫能量值在t=7时刻无额外增加，仍然是13.
+ 所有蛋仔都逃出迷官的总时间为6。















