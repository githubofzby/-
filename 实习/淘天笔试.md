# 第一题

## 题目描述

对于给定的k个数组，第之个数组由 n;个整数组成。
现在想要知道，是否存在这样两个不同的数组，使得这两个数组各自删除一个整数后，这两个数组剩下的元素的和相等。

## 输入描述

每个测试文件均包含多组测试数据。第一行输入一个整数 T(1 ≤ T ≤ 10)代表数据组数，每组测试数据描述如下：

第一行输入一个整数 k(1 <= k <= 10)代表数组个数，此后，对于第i个数组:

+ 第一行输入一个整数ni(1 ≦ ni ≤ 105)代表第之个数组中元素的数量。
+ 第二行输入ni个整数ai,1, ai,2,...,ai,ni(0<= aij <=2x10^4)代表第i个数组中的元素

除此之外，保证单个测试文件的 n 之和不超过5x10^5.

## 输出描述

对丁每组测试数据，新起一行。如果存在两个数组，使得这两个数组各自删除一个整数后，这两个数组剩下的元素的和相等，则输出YES反之输出No

## 代码

```java
import java.util.*;

public class ArraySumAfterDeletion {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt(); // 测试用例数量
        for (int t = 0; t < T; t++) {
            int k = scanner.nextInt(); // 数组个数
            // 存储每个数组可能的和（删除一个元素后）
            List<Set<Long>> possibleSums = new ArrayList<>();
            for (int i = 0; i < k; i++) {
                int n = scanner.nextInt(); // 当前数组的元素数量
                int[] arr = new int[n];
                // 读取数组元素
                for (int j = 0; j < n; j++) {
                    arr[j] = scanner.nextInt();
                }
                // 计算数组总和
                long totalSum = 0;
                for (int num : arr) {
                    totalSum += num;
                }
                // 计算删除每个元素后的和
                Set<Long> sumsAfterDeletion = new HashSet<>();
                for (int num : arr) {
                    sumsAfterDeletion.add(totalSum - num);
                }
                possibleSums.add(sumsAfterDeletion);
            }
            // 检查是否存在两个不同数组有相同的和
            boolean found = false;
            for (int i = 0; i < possibleSums.size(); i++) {
                for (int j = i + 1; j < possibleSums.size(); j++) {
                    // 检查两个不同数组的可能和是否有交集
                    for (Long sum : possibleSums.get(i)) {
                        if (possibleSums.get(j).contains(sum)) {
                            found = true;
                            break;
                        }
                    }
                    if (found) break;
                }
                if (found) break;
            }
            System.out.println(found ? "YES" : "NO");
        }
        scanner.close();
    }
}
```

# 第二题

## 题目表述

小红现在有每种小写字母若干个，她想把这些字母组成一个字符串 s，使得字符串s任意两个相邻字母都不一样，请你帮助她求出最长字符串的长度。

## 输入描述

每个测试文件均包含多组测试数。第一行输入一个整数 T(1 <= T <= 1000),代表数据组数,每组测试数据描述如下：

对于每一组测试数据:
每行 26 个整数，依次表示 a~z 的字母数量$x_i(0 ≤ x_i≤ 10^9)$.

## 输出描述

每组数据输出一个整数，表示满足条件的最长字符串的长度。

## 代码

```java
import java.util.*;

public class MaxLengthString {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt(); // 测试用例数量
        for (int t = 0; t < T; t++) {
            // 读取每个字母的数量
            long[] letters = new long[26];
            for (int i = 0; i < 26; i++) {
                letters[i] = scanner.nextLong();
            }
            // 找出数量最多的字母，遍历所有字母，找出数量最多的字母及其数量maxCount
            long maxCount = 0;
            for (int i = 0; i < 26; i++) {
                maxCount = Math.max(maxCount, letters[i]);
            }
            // 计算所有字母的总数，然后减去最多字母的数量，得到其他字母的总数otherCount
            long otherCount = 0;
            for (int i = 0; i < 26; i++) {
                otherCount += letters[i];
            }
            otherCount -= maxCount; // 减去最多的字母数量
            /* 计算最长字符串长度 
            	如果最多的字母数量 maxCount ≤ 其他字母数量 otherCount + 1：则可以将所有字母都用上，最长字符串长度为 maxCount + otherCount
            	否则：最多的字母最多只能使用 otherCount + 1 个（因为每个最多字母都需要被其他字母分隔），因此最长字符串长度为 2 * otherCount + 1
            */
            long result;  
            if (maxCount <= otherCount + 1) {
                // 如果最多的字母数量不超过其他字母数量+1，则可以全部用上
                result = maxCount + otherCount;
            } else {
                // 否则，只能使用 2 * otherCount + 1 个字母
                // 因为最多的字母最多只能占用 otherCount + 1 个位置
                result = 2 * otherCount + 1;
            }
            System.out.println(result);
        }
        scanner.close();
    }
}
```

# 第三题

## 题目表述

一棵树由n 个节点构成，1号点是根节点，每个节点都记录着一个数字，初始每个节点的数字为 $a_i$。现在需要将树上所有节点的数字调和为零：

具体来说，小红可以进行如下操作:

+ 选择树中的任一节点v及一个非负整数x.
+ 将 υ 以及 v的子树中所有与 v 距离为偶数的节点的权值进行异或操作，即更新为:$a[u]=a[u] \otimes x$
+ 每进行一次此操作就产生 x 的代价。

请问小红至少需要花费多少总代价，才能使得所有节点的符文权值均变为 0?我们可以证明，一定存在一种方法，能在有限操作次数内达成目标，答案一定存在。

## 名词解释

在一棵树中，对于任一节点 v，以v为根节点并包含所有从 v出发可以达到的后代节点(包括v自身)的集合构成了v的子树。在树中，任意两个节点之间仅存在一条简单路径，该路径上所经过的边的数目定义为这两个节点之间的距离。

## 输入描述

第一行包含一个整数 n，表示节点的数量。
第二行包含几 个整数 a1,a2,··,an，表示各节点的初始权值。
接下来n - 1行，每行包含两个整数 u 和 v，表示树中一条边。所给边构成一棵以1为根的树
1 <= n <= 2x10^5
0 ≤ ai ≦ 10^9

## 输出描述

输出一个整数，表示将所有节点的权值变为0 所需的最小总代价。

## 代码

```java
import java.util.*;

public class Main {
    static List<List<Integer>> tree; // 使用邻接表存储树结构
    static int[] a;    // 存储每个节点的初始权值
    static int[] depth;     // 存储每个节点的深度
    static long totalCost;     // 记录总操作代价

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        // 初始化权值数组
        a = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
        }
        // 初始化邻接表
        tree = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            tree.add(new ArrayList<>());
        }
        // 读取树的边结构
        for (int i = 0; i < n - 1; i++) {
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            tree.get(u).add(v);
            tree.get(v).add(u);
        }
        // 初始化深度数组和总代价
        depth = new int[n + 1];
        totalCost = 0;
        // 从根节点开始DFS
        dfs(1, 0, -1);
        // 输出总代价
        System.out.println(totalCost);
    }

    static void dfs(int u, int d, int parent) {
        // 记录当前节点的深度
        depth[u] = d;
        // 遍历子节点
        for (int v : tree.get(u)) {
            if (v != parent) {
                dfs(v, d + 1, u);
            }
        }
        
        // 如果当前节点权值不为0，执行操作
        if (a[u] != 0) {
            int x = a[u];
            totalCost += x;
            // 更新当前节点和受影响的节点
            updateTree(u, parent, x);
        }
    }

    // 更新节点及其子树
    static void updateTree(int u, int parent, int x) {
        // 更新当前节点
        a[u] ^= x;
        
        // 遍历相邻节点
        for (int v : tree.get(u)) {
            if (v != parent) {
                // 更新子树中与当前节点距离为偶数的节点
                updateSubtree(v, u, x, 1);
            }
        }
        
        // 如果有父节点，也需要向上更新
        if (parent != -1) {
            updateParent(parent, u, x, 1);
        }
    }
    
    // 向下更新子树
    static void updateSubtree(int u, int parent, int x, int dist) {
        // 如果距离为偶数，更新节点值
        if (dist % 2 == 0) {
            a[u] ^= x;
        }
        
        // 递归处理子节点
        for (int v : tree.get(u)) {
            if (v != parent) {
                updateSubtree(v, u, x, dist + 1);
            }
        }
    }
    
    // 向上更新父节点路径
    static void updateParent(int u, int child, int x, int dist) {
        // 如果距离为偶数，更新节点值
        if (dist % 2 == 0) {
            a[u] ^= x;
        }
        
        // 向上递归
        for (int v : tree.get(u)) {
            if (v != child && v != depth[u] - 1) { // 避免回到子节点或已处理的父节点
                updateSubtree(v, u, x, dist + 1);
            }
        }
    }
}
```









