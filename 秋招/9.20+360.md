题目描述:

定义一个序列的权重为该序列中出现过至少1次的数字之和，例如[1,2,2,3,3,6,4,4]的权重为1+2+3+4+6=16. 

给定一个长度为n的序列A[1],A[2]…A[n]，现在要将该序列划分为k段连续的序列，请问划分后最大的权重之和是多少? 

输入描述： 第一行两个用空格隔开的正整数n和k，分别表示序列的长度和划分的段数。 接下来一行n个用空格隔开的正整数A[1],A[2].…A[n]，表示序列中的元素值。 1<=k<=n<=500,1<=A[i]<=1000 

输出： 一个正整数，表示将序列划分为k段后最大的权重之和

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] A = new int[n + 1]; // 1-indexed
        
        for (int i = 1; i <= n; i++) {
            A[i] = sc.nextInt();
        }
        
        // 预计算所有区间的权重
        int[][] weight = new int[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            Set<Integer> seen = new HashSet<>();
            int sum = 0;
            for (int j = i; j <= n; j++) {
                if (!seen.contains(A[j])) {
                    seen.add(A[j]);
                    sum += A[j];
                }
                weight[i][j] = sum;
            }
        }
        
        // 动态规划
        // dp[i][j] 表示前i个元素划分为j段的最大权重和
        int[][] dp = new int[n + 1][k + 1];
        
        // 初始化为负无穷，表示不可达状态
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                dp[i][j] = Integer.MIN_VALUE;
            }
        }
        
        dp[0][0] = 0; // 前0个元素划分为0段，权重和为0
        
        // 状态转移
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.min(i, k); j++) {
                // 枚举最后一段的起始位置
                for (int last = j; last <= i; last++) {
                    if (dp[last - 1][j - 1] != Integer.MIN_VALUE) {
                        dp[i][j] = Math.max(dp[i][j], 
                                          dp[last - 1][j - 1] + weight[last][i]);
                    }
                }
            }
        }
        
        System.out.println(dp[n][k]);
        sc.close();
    }
}
```

小明在玩一款叫做激光射击的游戏。
游戏在一个平面直角坐标系上进行。游戏的场地为一个nxm 的矩形区域，其中矩形的四个顶点分别为(0,0),(n,0),(n,m).(0,m)。一東激光装置放置在 (0,0)的位置，玩家可以向区域内任意方向发射一束激光。激光会沿着直线行进，当其抵达矩形区域的某个边界时，它会从跟该边界平行的另一个边界射出，方向不变。具体的，当激光抵达边界 (n,y), 0<y<m 时，激光会从 (0,y)射出;当激光抵达边界 (x,m), 0<x<n时，激光会从 (x,0)射出; 然而在(n,m) 处有一个吸收装置，当激光抵达边界(n,m)时激光会被吸收。区域内有若干个靶，每个靶都可以看作一个点，并且其坐标均为整数。当激光击中靶子时，靶子会消失，同时玩家得一分。小明希望自己的得分最大。请计算小明可以获得的最大得分是多少。

输入描述
第一行三个整数n,m,k(2≤n,m≤50,1≤k≤(n-1)(m1))，表示矩形区域的大小以及靶子的数量。接下来k行，每行两个整数x,y(1≤x<n,1≤y<m)表示靶子的坐标。保证所有靶子的坐标都不相同。
输出描述
一个整数，表示小明可以获得的最大得分

样例输入

```5 5 7
5 5 7
1 3
1 4
2 1
2 2
3 3
3 4
4 2
```

输出：

```
4
```


```java
import java.util.*;

public class Main {
    static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();
        int[][] targets = new int[k][2];
        for (int i = 0; i < k; i++) {
            targets[i][0] = sc.nextInt();
            targets[i][1] = sc.nextInt();
        }

        int ans = 0;

        // 遍历每个靶子，计算其方向
        for (int i = 0; i < k; i++) {
            int x = targets[i][0];
            int y = targets[i][1];

            // 用集合避免重复计数
            Set<String> hit = new HashSet<>();
            for (int j = 0; j < k; j++) {
                int xx = targets[j][0];
                int yy = targets[j][1];

                // 判断 (xx,yy) 是否在从 (0,0) 出发，击中 (x,y) 的方向上
                // 即 (xx,yy) 与 (x,y) 在平铺展开后共线
                int dx = xx - 0;
                int dy = yy - 0;
                int g = gcd(Math.abs(dx), Math.abs(dy));
                dx /= g; dy /= g;

                // 确保方向唯一
                if (dx < 0 || (dx == 0 && dy < 0)) {
                    dx = -dx;
                    dy = -dy;
                }

                hit.add(dx + "," + dy);
            }
            ans = Math.max(ans, hit.size());
        }

        System.out.println(ans);
    }
}

```











