查找一个矩阵上路径最短算法;例如
[2,3,1,4],
[2,5,3,6]
[4,2,1,4]
计算出从左上第一个，走到右边下最后一个，需要走的最短路径
示例：
输入
[[1,3,1], [3,5,3], [3,2,1]]
输出
9

```java
public class MinPathSum {
    public static int minPathSum(int[][] grid) {
        int m = grid.length;       // 行数
        int n = grid[0].length;    // 列数
        
        int[][] dp = new int[m][n];
        // 初始化起点
        dp[0][0] = grid[0][0];
        // 初始化第一行
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }
        // 初始化第一列
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        // 填充其他位置
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[m-1][n-1];
    }
    
    public static void main(String[] args) {
        int[][] grid1 = {
            {1, 3, 1},
            {3, 5, 3},
            {3, 2, 1}
        };
        
        int[][] grid2 = {
            {2, 3, 1, 4},
            {2, 5, 3, 6},
            {4, 2, 1, 4}
        };
        
        System.out.println("示例1最短路径和: " + minPathSum(grid1)); // 9
        System.out.println("示例2最短路径和: " + minPathSum(grid2));
    }
}

```

木桶效应是指，一个木桶能盛放的水的量取决于最矮的木板长度。已知一个圆桶边缘最低处高度为 h，圆底周长为 w，则可以装下最多的水的容量为 h*根号w。
小A现在手上有一块宽度为 n 的铁皮，但是铁皮并不平整，每个1单位宽度对应的高度都不相同。小A想用这块铁皮制造x个铁桶，于是他会纵向砍x-1刀将铁皮分块，且每块的宽度都是整数，之后再分别把每块铁皮卷成一个圆柱形，圆柱的圆底周长等于铁皮的宽度，圆柱的高度等于这段铁皮高度的最小值。假设用来制作铁桶圆底面的材料有无限多，请你算他怎么切才能使得 x个铁桶可以盛放的水的总量最大。

输入描述
第一行一个正整数
n,x(l<=n≤1000,1<x<min(n,20))代表现有铁皮的宽度和小A需要的铁桶数。

第二行n个整数，每个数c(1 ≤ c< 500)代表铁皮每单位宽度对应的高度。

输出描述
1个浮点数，代表可以盛放的最多水的容量。输出的结果和答案的绝对误差或相对误差在 10的-5次方之内即被认为正确。

> 解释

这个题其实是一个**区间划分 + 动态规划**问题。我们要把一块宽度为 `n` 的铁皮切成 `x` 段，每一段卷成一个圆桶，桶的容量公式是：
$$
容量 = h \times \sqrt{w}
$$

#### 解题思路

1. **预处理最小值**

   - 我们需要频繁得到任意区间 `[l, r]` 的最小高度。
   - 可以用二维数组 `minHeight[l][r]` 预处理所有区间的最小值（复杂度 O(n²)）。

2. **动态规划定义**

   - `dp[i][j]` 表示前 `i` 个单位铁皮切成 `j` 段后，能得到的最大水量。

   - 转移方程：
     $$
     dp[i][j] = \max_{k< i} \Big(dp[k][j-1] + minHeight[k+1][i] \times \sqrt{i-k}\Big)
     $$

```java
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), x = sc.nextInt();
        int[] h = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            h[i] = sc.nextInt();
        }

        // 预处理区间最小值
        int[][] minHeight = new int[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            minHeight[i][i] = h[i];
            for (int j = i + 1; j <= n; j++) {
                minHeight[i][j] = Math.min(minHeight[i][j - 1], h[j]);
            }
        }

        // dp[i][j] 表示前 i 段切成 j 段的最大水量
        double[][] dp = new double[n + 1][x + 1];

        // 初始化 j=1 的情况
        for (int i = 1; i <= n; i++) {
            dp[i][1] = minHeight[1][i] * Math.sqrt(i);
        }

        // 递推
        for (int j = 2; j <= x; j++) { // 段数
            for (int i = j; i <= n; i++) { // 至少要 i >= j
                for (int k = j - 1; k < i; k++) { // 前一刀位置
                    dp[i][j] = Math.max(dp[i][j],
                            dp[k][j - 1] + minHeight[k + 1][i] * Math.sqrt(i - k));
                }
            }
        }

        System.out.printf("%.6f\n", dp[n][x]);
    }
}

```



```java
import java.util.*;
import java.io.*;

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] line1 = br.readLine().split(" ");
        int n = Integer.parseInt(line1[0]);
        int x = Integer.parseInt(line1[1]);
        
        String[] line2 = br.readLine().split(" ");
        int[] heights = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            heights[i] = Integer.parseInt(line2[i - 1]);
        }
        
        // 预计算每个区间[i,j]的最小高度
        int[][] minHeight = new int[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            minHeight[i][i] = heights[i];
            for (int j = i + 1; j <= n; j++) {
                minHeight[i][j] = Math.min(minHeight[i][j - 1], heights[j]);
            }
        }
        
        // dp[i][j] 表示前i个单位分成j个铁桶的最大容量
        double[][] dp = new double[n + 1][x + 1];
        
        // 初始化：前i个单位分成1个铁桶
        for (int i = 1; i <= n; i++) {
            dp[i][1] = minHeight[1][i] * Math.sqrt(i);
        }
        
        // 动态规划
        for (int i = 2; i <= n; i++) {
            for (int j = 2; j <= Math.min(i, x); j++) {
                // 枚举最后一个铁桶的起始位置
                for (int k = j - 1; k < i; k++) {
                    int width = i - k;  // 最后一个铁桶的宽度
                    double capacity = minHeight[k + 1][i] * Math.sqrt(width);
                    dp[i][j] = Math.max(dp[i][j], dp[k][j - 1] + capacity);
                }
            }
        }
        
        System.out.printf("%.6f\n", dp[n][x]);
    }
}
```













